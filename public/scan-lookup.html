<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>æŠœå‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ï½œç”Ÿç”£ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root {
    --ok: #1c7ed6; --ng: #e03131; --loc: #2b8a3e; --info: #f59f00;
    --tx: #212529; --sub: #6c757d; --bg: #f8f9fa; --bd: #dee2e6;
    --primary: #1c7ed6; --secondary: #6c757d; --success: #22c55e; --warning: #f59e0b;
    --bg-ok: #e7f5ff; --bg-ng: #fff5f5; --bg-loc: #e6fcf5; --bg-info: #fff9db;
  }
  
  html, body {
    margin: 0; background: var(--bg); color: var(--tx);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
  }

  /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
  .wrap {
    max-width: 1100px;
    margin: 0 auto;
    padding: 16px;
  }

  /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
  .page-header {
    background: #fff;
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    border: 1px solid var(--bd);
  }
  .header-content {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 20px;
  }
  .back-btn {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 8px 12px;
    border-radius: 10px;
    transition: background 0.2s;
    color: var(--sub);
  }
  .back-btn:hover {
    background: #f1f3f5;
  }
  .header-text {
    flex: 1;
  }
  .header-text h1 {
    margin: 0 0 6px 0;
    font-size: 24px;
    font-weight: 700;
    color: var(--tx);
  }
  .subtitle {
    margin: 0;
    font-size: 14px;
    color: var(--sub);
  }
  .header-badges {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .status-badge {
    padding: 6px 12px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 600;
    background: #e9ecef;
    color: #495057;
    border: 1px solid #dee2e6;
  }

  /* ã‚¿ãƒ–ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ */
  .tab-nav {
    display: flex;
    background: #f8f9fa;
    border-radius: 12px;
    padding: 6px;
    gap: 4px;
  }
  .tab-btn {
    flex: 1;
    padding: 12px 16px;
    border: none;
    background: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.2s;
    color: var(--sub);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  .tab-btn.active {
    background: #fff;
    color: var(--primary);
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }
  .tab-btn .icon {
    font-size: 16px;
  }

  /* ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
  .tab-content {
    display: none;
    animation: fadeIn 0.3s ease;
  }
  .tab-content.active {
    display: block;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* ã‚«ãƒ¼ãƒ‰ */
  .card {
    background: #fff;
    border: 1px solid var(--bd);
    border-radius: 16px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    padding: 20px;
    margin-bottom: 20px;
    transition: box-shadow 0.2s;
  }
  .card:hover {
    box-shadow: 0 6px 20px rgba(0,0,0,0.08);
  }
  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    gap: 12px;
  }
  .card-header h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: var(--tx);
    flex: 1;
  }

  /* ã‚¹ã‚­ãƒ£ãƒŠãƒ¼ */
  .scanner-container {
    position: relative;
  }
  .stack {
    position: relative;
    border: 1px solid var(--bd);
    border-radius: 12px;
    overflow: hidden;
    background: #000;
    margin-bottom: 16px;
  }
  video {
    display: block;
    width: 100%;
    max-width: 580px;
    background: #000;
    border-radius: 8px;
  }
  canvas {
    position: absolute;
    inset: 0;
    pointer-events: none;
    border-radius: 8px;
  }

  /* ã‚¹ã‚­ãƒ£ãƒ³ã‚¬ã‚¤ãƒ‰ */
  .scan-guide {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1;
    pointer-events: none;
  }
  .guide-frame {
    width: 200px;
    height: 200px;
    border: 3px solid #fff;
    border-radius: 12px;
    box-shadow: 0 0 0 1000px rgba(0,0,0,0.4);
    position: relative;
  }
  .guide-frame::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 180px;
    height: 180px;
    border: 2px dashed rgba(255,255,255,0.6);
    border-radius: 8px;
  }
  .guide-text {
    color: #fff;
    text-align: center;
    margin-top: 220px;
    font-weight: 600;
    font-size: 14px;
    text-shadow: 0 1px 3px rgba(0,0,0,0.7);
    background: rgba(0,0,0,0.7);
    padding: 8px 16px;
    border-radius: 20px;
    backdrop-filter: blur(10px);
  }

  /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
  .scanner-controls {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 16px;
  }
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    text-decoration: none;
    font-size: 14px;
    border: 1px solid transparent;
  }
  .btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
  }
  .btn:not(:disabled):hover {
    transform: translateY(-2px);
  }
  .btn.primary {
    background: var(--primary);
    color: #fff;
    box-shadow: 0 2px 8px rgba(28,126,214,0.3);
  }
  .btn.primary:not(:disabled):hover {
    background: #1971c2;
    box-shadow: 0 4px 12px rgba(28,126,214,0.4);
  }
  .btn.secondary {
    background: var(--secondary);
    color: #fff;
  }
  .btn.outline {
    background: transparent;
    border: 1px solid var(--bd);
    color: var(--sub);
  }
  .btn.outline:hover {
    background: #f8f9fa;
    border-color: var(--primary);
    color: var(--primary);
  }
  .btn.icon {
    padding: 12px;
    aspect-ratio: 1;
  }
  .btn.large {
    padding: 14px 24px;
    font-size: 16px;
  }
  .btn-icon {
    font-size: 16px;
  }

  /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
  .scan-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .scan-status {
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    border: 1px solid;
  }
  .scan-status.ready {
    background: var(--bg-ok);
    color: var(--ok);
    border-color: #a5d8ff;
  }
  .scan-status.scanning {
    background: var(--bg-info);
    color: #e67700;
    border-color: #ffd8a8;
  }
  .scan-status.error {
    background: var(--bg-ng);
    color: var(--ng);
    border-color: #ffc9c9;
  }
  .scan-status.locked {
    background: #f3f0ff;
    color: #7048e8;
    border-color: #d0bfff;
  }
  .scan-status.loc {
    background: var(--bg-loc);
    color: var(--loc);
    border-color: #96f2d7;
  }

  /* ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæƒ…å ± */
  .target-info {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
    margin-bottom: 16px;
  }
  .target-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .target-label {
    font-size: 14px;
    color: var(--sub);
    font-weight: 500;
  }
  .target-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--primary);
  }
  .shelf-info {
    background: var(--bg-loc);
    color: var(--loc);
    padding: 12px 16px;
    border-radius: 12px;
    border: 1px solid #96f2d7;
    margin-top: 8px;
  }
  .shelf-label {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 4px;
  }
  .shelf-value {
    font-size: 18px;
    font-weight: 700;
  }

  /* å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ  */
  .input-group {
    display: flex;
    gap: 16px;
    margin-bottom: 20px;
  }
  .input-field {
    flex: 1;
  }
  .input-field label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: var(--tx);
    font-size: 14px;
  }
  .text-input, .select-input {
    width: 100%;
    padding: 12px 16px;
    border: 1px solid var(--bd);
    border-radius: 10px;
    font-size: 14px;
    transition: all 0.2s;
    background: #fff;
  }
  .text-input:focus, .select-input:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(28,126,214,0.1);
  }

  .action-buttons {
    display: flex;
    gap: 12px;
  }
  .action-buttons .btn {
    flex: 1;
  }

  /* å‡¡ä¾‹ */
  .legend {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-top: 16px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 13px;
    color: var(--sub);
  }
  .legend-color {
    width: 16px;
    height: 16px;
    border-radius: 4px;
    border: 2px solid;
  }
  .legend-color.ok { background: var(--bg-ok); border-color: var(--ok); }
  .legend-color.loc { background: var(--bg-loc); border-color: var(--loc); }
  .legend-color.ng { background: var(--bg-ng); border-color: var(--ng); }

  /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
  .modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.5);
    animation: modal-fade-in 0.3s ease;
  }
  .modal-content {
    background-color: #fff;
    margin: 10% auto;
    padding: 20px;
    border: none;
    border-radius: 16px;
    width: 80%;
    max-width: 600px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
  }
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--bd);
    padding-bottom: 12px;
    margin-bottom: 12px;
  }
  .modal-header h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
  }
  .close-button {
    color: #aaa;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    transition: color 0.2s;
  }
  .close-button:hover {
    color: #555;
  }
  #historyList {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 400px;
    overflow-y: auto;
  }
  #historyList li {
    padding: 10px 0;
    border-bottom: 1px solid #eee;
    font-size: 14px;
  }
  #historyList li:last-child {
    border-bottom: none;
  }

  /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  .error-message {
    background: var(--bg-ng);
    color: var(--ng);
    padding: 12px 16px;
    border-radius: 8px;
    border: 1px solid #ffc9c9;
    font-size: 14px;
    font-weight: 500;
    margin-top: 8px;
  }

  /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
  @media (max-width: 768px) {
    .wrap {
      padding: 12px;
    }
    .header-content {
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }
    .header-badges {
      align-self: stretch;
      justify-content: flex-start;
    }
    .input-group {
      flex-direction: column;
      gap: 12px;
    }
    .scanner-controls {
      justify-content: center;
    }
    .guide-frame {
      width: 150px;
      height: 150px;
    }
    .guide-text {
      margin-top: 170px;
      font-size: 12px;
    }
    .tab-btn {
      padding: 10px 12px;
      font-size: 13px;
    }
    .target-info {
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }
  }

  /* ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ */
  .toast {
    position: absolute;
    padding: 8px 12px;
    background: #000c;
    color: #fff;
    border-radius: 8px;
    font-size: 13px;
    transform: translate(-50%, -150%);
    pointer-events: none;
    animation: fade-out 1.2s forwards;
    z-index: 1000;
  }
  @keyframes fade-out {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  /* å¤§ããªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  .bigmsg {
    position: fixed;
    left: 50%;
    top: 18%;
    transform: translateX(-50%);
    z-index: 1200;
    background: rgba(28, 126, 214, 0.95);
    color: #fff;
    padding: 16px 22px;
    border-radius: 12px;
    font-size: clamp(18px, 3.2vw, 26px);
    box-shadow: 0 8px 24px rgba(0,0,0,.2);
    letter-spacing: .02em;
    text-align: center;
    pointer-events: none;
    animation: bigmsg-fade 1.2s ease-out forwards;
  }
  .bigmsg .sub {
    display: block;
    font-size: .8em;
    opacity: .9;
    margin-top: 2px;
  }
  @keyframes bigmsg-fade {
    0%   { opacity: 0; transform: translateX(-50%) translateY(-8px); }
    10%  { opacity: 1; transform: translateX(-50%) translateY(0); }
    80%  { opacity: 1; }
    100% { opacity: 0; transform: translateX(-50%) translateY(-8px); }
  }

  @keyframes modal-fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
  <div class="page-header">
    <div class="header-content">
      <button class="back-btn" onclick="history.back()" aria-label="æˆ»ã‚‹">â†</button>
      <div class="header-text">
        <h1>æŠœå‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼</h1>
        <p class="subtitle">QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ç›®çš„ã®æŠœå‹ã¨æ£šã‚’æ¢ã—ã¾ã™</p>
      </div>
      <div class="header-badges">
        <span id="detectorInfo" class="status-badge">æº–å‚™ä¸­</span>
        <span id="scanStatus" class="status-badge">å¾…æ©Ÿä¸­</span>
      </div>
    </div>
    
    <!-- ã‚¿ãƒ–ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ -->
    <div class="tab-nav">
      <button class="tab-btn active" data-tab="scanner">
        <span class="icon">ğŸ“·</span>
        ã‚¹ã‚­ãƒ£ãƒŠãƒ¼
      </button>
      <button class="tab-btn" data-tab="target">
        <span class="icon">ğŸ¯</span>
        ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š
      </button>
      <button class="tab-btn" data-tab="history">
        <span class="icon">ğŸ“‹</span>
        å±¥æ­´
      </button>
    </div>
  </div>

  <!-- ã‚¹ã‚­ãƒ£ãƒŠãƒ¼ã‚¿ãƒ– -->
  <div class="tab-content active" id="scanner-tab">
    <div class="card">
      <div class="card-header">
        <h3>QRã‚³ãƒ¼ãƒ‰ã‚¹ã‚­ãƒ£ãƒ³</h3>
        <div class="scan-indicator">
          <span id="scanStatusBadge" class="scan-status ready">æº–å‚™å®Œäº†</span>
        </div>
      </div>
      
      <div class="scanner-container">
        <div class="stack" id="stack">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
          
          <!-- ã‚¹ã‚­ãƒ£ãƒ³ã‚¬ã‚¤ãƒ‰ -->
          <div class="scan-guide">
            <div class="guide-frame"></div>
            <div class="guide-text">QRã‚³ãƒ¼ãƒ‰ã‚’æ å†…ã«ã‹ã–ã—ã¦ãã ã•ã„</div>
          </div>
        </div>
        
        <div class="scanner-controls">
          <button id="btnStart" class="btn primary large">
            <span class="btn-icon">ğŸ“·</span>
            ã‚«ãƒ¡ãƒ©é–‹å§‹
          </button>
          <button id="btnStop" class="btn secondary" disabled>
            <span class="btn-icon">â¹ï¸</span>
            åœæ­¢
          </button>
          <button class="btn icon outline" id="btnFlipCamera" title="ã‚«ãƒ¡ãƒ©åˆ‡æ›¿" disabled>
            ğŸ”„
          </button>
          <label class="btn icon outline" style="cursor:pointer" title="ç”»åƒãƒ†ã‚¹ãƒˆ">
            ğŸ“
            <input id="fileTest" type="file" accept="image/*" style="display:none">
          </label>
        </div>
        
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color ok"></div>
            <span>ä¸€è‡´ï¼ˆå‹ï¼‰</span>
          </div>
          <div class="legend-item">
            <div class="legend-color loc"></div>
            <span>ä¸€è‡´ï¼ˆæ£šï¼‰</span>
          </div>
          <div class="legend-item">
            <div class="legend-color ng"></div>
            <span>ä¸ä¸€è‡´</span>
          </div>
        </div>

        <div id="error" class="error-message" style="display:none"></div>
      </div>
    </div>

    <!-- ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¡¨ç¤º -->
    <div class="card">
      <div class="card-header">
        <h3>ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ</h3>
      </div>
      <div class="target-info">
        <div class="target-item">
          <span class="target-label">Book</span>
          <span id="tgtBN" class="target-value">-</span>
        </div>
        <div class="target-item">
          <span class="target-label">WC</span>
          <span id="tgtWC" class="target-value">-</span>
        </div>
        <div class="target-item">
          <span class="target-label">Work Name</span>
          <span id="tgtWN" class="muted">-</span>
        </div>
      </div>
      
      <div class="shelf-info">
        <div class="shelf-label">æ¢ã™ã¹ãæ£š</div>
        <div id="currentShelf" class="shelf-value">ï¼ˆæœªè¨­å®šï¼‰</div>
      </div>
    </div>
  </div>

  <!-- ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®šã‚¿ãƒ– -->
  <div class="tab-content" id="target-tab">
    <div class="card">
      <div class="card-header">
        <h3>æ‰‹å‹•ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š</h3>
        <span class="muted">Bookã¨WCã‚’ç›´æ¥æŒ‡å®š</span>
      </div>
      
      <div class="input-group">
        <div class="input-field">
          <label for="inBook">Bookã‚³ãƒ¼ãƒ‰</label>
          <select id="inBook" class="select-input">
            <option value="" disabled selected>é¸æŠã—ã¦ãã ã•ã„</option>
            <option value="Ko">Ko</option>
            <option value="Ta">Ta</option>
            <option value="Yo">Yo</option>
          </select>
        </div>
        <div class="input-field">
          <label for="inWc">WCã‚³ãƒ¼ãƒ‰</label>
          <input type="text" id="inWc" placeholder="ä¾‹: 2356" class="text-input">
        </div>
      </div>
      
      <div class="action-buttons">
        <button id="btnSetTarget" class="btn primary">
          <span class="btn-icon">ğŸ¯</span>
          ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š
        </button>
      </div>
      
      <div class="muted" style="font-size:13px;margin-top:12px;">
        ãƒ»Bookã¯ Ko / Ta / Yo ã‹ã‚‰é¸æŠã§ãã¾ã™<br>
        ãƒ»è¨­å®šå¾Œã¯ã€è©²å½“ã®æ£šï¼ˆLocationï¼‰ã‚‚è‡ªå‹•å–å¾—ã—ã¾ã™
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <h3>ğŸ’¡ ä½¿ã„æ–¹</h3>
      </div>
      <div class="muted" style="font-size:14px;line-height:1.6;">
        <p><strong>1. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š</strong><br>
        ãƒ»URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (?book=...&wc=...&loc=...) ã§æŒ‡å®š<br>
        ãƒ»ä½œæ¥­æŒ‡ç¤ºQRã‚’ã‚¹ã‚­ãƒ£ãƒ³<br>
        ãƒ»æ‰‹å‹•ã§Book/WCã‚’å…¥åŠ›</p>
        
        <p><strong>2. ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹</strong><br>
        ãƒ»æŠœå‹QRã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ä¸€è‡´ã‚’ç¢ºèª<br>
        ãƒ»æ£šQRã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ä½ç½®ã‚’ç¢ºèª</p>
        
        <p><strong>3. ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</strong><br>
        ãƒ»ä¸€è‡´æ™‚: é’æ  + éŸ³å£° + æŒ¯å‹•<br>
        ãƒ»æ£šä¸€è‡´: ç·‘æ  + éŸ³å£°æ¡ˆå†…</p>
      </div>
    </div>
  </div>

  <!-- å±¥æ­´ã‚¿ãƒ– -->
  <div class="tab-content" id="history-tab">
    <div class="card">
      <div class="card-header">
        <h3>ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´</h3>
        <button id="btnShowHistory" class="btn outline">
          <span class="btn-icon">ğŸ“‹</span>
          å±¥æ­´ã‚’è¡¨ç¤º
        </button>
      </div>
      <div class="muted" style="text-align:center;padding:40px 20px;">
        å±¥æ­´ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„<br>
        <small>æœ€å¤§50ä»¶ã¾ã§ä¿å­˜ã•ã‚Œã¾ã™</small>
      </div>
    </div>
  </div>
</div>

<!-- å±¥æ­´ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="historyModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´</h3>
      <span id="closeModal" class="close-button">&times;</span>
    </div>
    <ul id="historyList"></ul>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" crossorigin="anonymous"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // ===== ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½ =====
  const tabBtns = document.querySelectorAll('.tab-btn');
  const tabContents = document.querySelectorAll('.tab-content');
  
  tabBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const tabId = this.getAttribute('data-tab');
      
      tabBtns.forEach(b => b.classList.remove('active'));
      tabContents.forEach(c => c.classList.remove('active'));
      
      this.classList.add('active');
      document.getElementById(`${tabId}-tab`).classList.add('active');
      
      if (tabId === 'scanner' && window.state && window.state.stream) {
        setTimeout(() => {
          fitOverlay();
        }, 100);
      }
    });
  });

  // ===== ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ =====
  const DOM = {
    video: document.getElementById('video'),
    overlay: document.getElementById('overlay'),
    stack: document.getElementById('stack'),
    btnStart: document.getElementById('btnStart'),
    btnStop: document.getElementById('btnStop'),
    btnFlipCamera: document.getElementById('btnFlipCamera'),
    tgtBN: document.getElementById('tgtBN'),
    tgtWC: document.getElementById('tgtWC'),
    tgtWN: document.getElementById('tgtWN'),
    currentShelf: document.getElementById('currentShelf'),
    scanStatusBadge: document.getElementById('scanStatusBadge'),
    detectorInfo: document.getElementById('detectorInfo'),
    error: document.getElementById('error'),
    fileTest: document.getElementById('fileTest'),
    historyModal: document.getElementById('historyModal'),
    historyList: document.getElementById('historyList'),
    closeModal: document.getElementById('closeModal'),
    btnShowHistory: document.getElementById('btnShowHistory'),
    inBook: document.getElementById('inBook'),
    inWc: document.getElementById('inWc'),
    btnSetTarget: document.getElementById('btnSetTarget'),
  };

  const overlayCtx = DOM.overlay.getContext('2d', { willReadFrequently: true });

  const state = {
    stream: null,
    rafId: null,
    detector: null,
    useBarcodeDetector: ('BarcodeDetector' in window),
    isLocked: false,
    holdTimer: null,
    currentTarget: {},
    targetKey: '',
    currentShelf: null,
    scanHistory: new Map(),
    __lastOrderKey: '',
    __orderSetAt: 0,
    csrf: '',
    facingMode: 'environment'
  };

  // ===== è¨­å®š =====
  const CONFIG = {
    colors: {
      ok: '#1c7ed6',
      ng: '#e03131',
      loc: '#2b8a3e',
      info: '#f59f00',
    },
    holdDuration: 3000,
    lockCooldown: 700,
    orderResetCooldownMs: 2000,
  };

  // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° =====
  function updateStatus(text, type = 'ready') {
    DOM.scanStatusBadge.textContent = text;
    DOM.scanStatusBadge.className = `scan-status ${type}`;
  }

  function showError(e) {
    console.error(e);
    DOM.error.textContent = `âŒ ${e?.name || ""} ${e?.message || e}`;
    DOM.error.style.display = 'block';
  }

  function clearError() {
    DOM.error.textContent = '';
    DOM.error.style.display = 'none';
  }

  // ===== éŸ³å£°é–¢é€£ =====
  let __jpVoices = [];
  let __lastSpeak = 0;
  let __lastLocSpeak = 0;
  const __speakCooldownMs = 1500;
  const __locSpeakCooldownMs = 3000;

  function initTTS() {
    if (!('speechSynthesis' in window)) return;
    const synth = window.speechSynthesis;
    function loadVoices() {
      const voices = synth.getVoices();
      __jpVoices = voices
        .filter(v => /ja|jpn|æ—¥æœ¬èª/i.test(v.lang) || /æ—¥æœ¬èª/i.test(v.name))
        .sort((a,b) => {
          const pref = ['Google æ—¥æœ¬èª', 'Kyoko', 'Otoya'];
          const ia = pref.findIndex(p => (a.name||'').includes(p));
          const ib = pref.findIndex(p => (b.name||'').includes(p));
          return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
        });
    }
    loadVoices();
    synth.onvoiceschanged = loadVoices;
  }

  const punct = s => String(s||"").replace(/\s+/g, ' ').trim();
  
  function unlockTTS() {
    if (!('speechSynthesis' in window)) return;
    const u = new SpeechSynthesisUtterance(' ');
    u.lang = 'ja-JP'; u.volume = 0; u.rate = 1; u.pitch = 1;
    try { window.speechSynthesis.speak(u); } catch {}
  }
  
  function speakAfterReady(utterance) {
    if (!('speechSynthesis' in window)) return;
    const synth = window.speechSynthesis;
    const trySpeak = (retries = 2) => {
      try { synth.cancel(); } catch {}
      const voices = synth.getVoices();
      if (voices && voices.length && __jpVoices.length === 0) {
        __jpVoices = voices.filter(v =>
          /ja|jpn|æ—¥æœ¬èª/i.test(v.lang) || /æ—¥æœ¬èª|Kyoko|Google æ—¥æœ¬èª/i.test(v.name)
        );
        if (__jpVoices.length) utterance.voice = __jpVoices[0];
      }
      try { synth.speak(utterance); }
      catch (e) { if (retries > 0) setTimeout(() => trySpeak(retries - 1), 200); }
    };
    trySpeak();
  }

  function speakFoundOnce(workName) {
    if (!('speechSynthesis' in window)) return;
    const now = performance.now();
    if (now - __lastSpeak < __speakCooldownMs) return;
    __lastSpeak = now;
    const hasWN = !!workName && String(workName).trim().length > 0;
    const text = hasWN ? `ãŠæ¢ã—ã®å‹ã€${workName}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚` : `ãŠæ¢ã—ã®å‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚`;
    const u = new SpeechSynthesisUtterance(punct(text));
    u.lang='ja-JP'; u.rate=1.0; u.pitch=1.1; u.volume=1.0;
    if (__jpVoices.length > 0) u.voice = __jpVoices[0];
    speakAfterReady(u);
  }

  function speakTargetLocFound() {
    if (!('speechSynthesis' in window)) return;
    const now = performance.now();
    if (now - __lastLocSpeak < __locSpeakCooldownMs) return;
    __lastLocSpeak = now;
    const u = new SpeechSynthesisUtterance("ç›®çš„ã®æ£šã§ã™");
    u.lang='ja-JP'; u.rate=1.0; u.pitch=1.1; u.volume=0.8;
    if (__jpVoices.length > 0) u.voice = __jpVoices[0];
    speakAfterReady(u);
  }

  let __lastGenericSpeak = 0;
  function speakLineOnce(text, {rate=1.08, pitch=1.4, cooldown=1200} = {}) {
    if (!('speechSynthesis' in window)) return;
    const now = performance.now();
    if (now - __lastGenericSpeak < cooldown) return;
    __lastGenericSpeak = now;
    const u = new SpeechSynthesisUtterance(punct(text));
    u.lang='ja-JP';u.rate=rate;u.pitch=pitch;u.volume=1.0;
    if (__jpVoices.length>0) u.voice=__jpVoices[0];
    speakAfterReady(u);
  }

  // ===== éŸ³å£°ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ =====
  const confirmationBeep = (() => {
    let audioCtx;
    const play = () => {
      try {
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const t0 = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, t0);
        osc.frequency.exponentialRampToValueAtTime(1200, t0 + 0.1);
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.0001, t0);
        gain.gain.exponentialRampToValueAtTime(0.4, t0 + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.2);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(t0);
        osc.stop(t0 + 0.25);
      } catch {}
    };
    return play;
  })();

  // ===== æ–‡å­—åˆ—æ­£è¦åŒ– =====
  const normalizeHyphen = s => (s || "").replace(/[â€-â€’â€“â€”â€•ãƒ¼âˆ’]/g, "-");

  // ===== QRã‚³ãƒ¼ãƒ‰åˆ†é¡ =====
  const classify = (raw) => {
    const text = normalizeHyphen((raw || "").trim());
    if (/^loc-/i.test(text)) return "loc";
    try { const url = new URL(text); if (url.searchParams.has("loc")) return "loc"; } catch {}
    if (/^die-/i.test(text)) return "die";
    try { const url = new URL(text); if (url.searchParams.has("book") || url.searchParams.has("wc")) return "die"; } catch {}
    if (/^order-/i.test(text)) return "order";
    if (/order[_-]?plain/i.test(text)) return "order";
    try { const url = new URL(text); if (/order[_-]?plain/i.test(url.pathname + url.search)) return "order"; } catch {}
    return "other";
  };

  // ===== ãƒ‘ãƒ¼ã‚µãƒ¼é–¢æ•° =====
  const tryExtractWN = (rawUrl) => {
    try {
      const u = new URL(rawUrl);
      const m = /[#&]d=([^&]+)/.exec(u.hash || "");
      if (!m) return "";
      const b64 = m[1].replace(/-/g, '+').replace(/_/g, '/');
      const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
      const json = atob(b64 + pad);
      const obj = JSON.parse(json);
      return (obj.wn || "").trim();
    } catch { return ""; }
  };

  const parseDie = (raw) => {
    const text = normalizeHyphen((raw || "").trim());
    let match = /^die-([^-\n]+)-([^-]+)(?:-(.+))?$/i.exec(text);
    if (match) return { bn: match[1].trim(), wc: match[2].trim(), wn: (match[3] || "").trim() };
    try {
      const url = new URL(text);
      const book = url.searchParams.get("book") || "";
      const wc = url.searchParams.get("wc") || "";
      if (book || wc) {
        const wnFromParam = (url.searchParams.get("wn") || "").trim();
        const wnFromHash = tryExtractWN(text);
        return { bn: book.trim(), wc: wc.trim(), wn: wnFromParam || wnFromHash };
      }
    } catch {}
    return null;
  };

  const parseLoc = (raw) => {
    const text = normalizeHyphen((raw || "").trim());
    let match = /^loc-(.+)$/i.exec(text);
    if (match) return { loc: match[1].trim() };
    try {
      const url = new URL(text);
      const loc = url.searchParams.get("loc") || "";
      if (loc) return { loc: loc.trim() };
    } catch {}
    return null;
  };

  const parseOrderPlain = (raw) => {
    const text = normalizeHyphen((raw || "").trim());
    let m = /^order-([^-\n]+)-([^-]+)(?:-(.+))?$/i.exec(text);
    if (m) return { bn: m[1].trim(), wc: m[2].trim() };
    try {
      const url = new URL(text);
      if (/order[_-]?plain/i.test(url.pathname + url.search)) {
        const book = (url.searchParams.get("book") || url.searchParams.get("Book") || "").trim();
        const wc   = (url.searchParams.get("wc")   || url.searchParams.get("WorkCord") || "").trim();
        if (book || wc) return { bn: book, wc };
      }
    } catch {}
    m = /order(?:[_-]?plain)?[:\s-]+([^\s/:-]+)[\s/:-]+([^\s/:-]+)/i.exec(text);
    if (m) return { bn: m[1].trim(), wc: m[2].trim() };
    return null;
  };

  const dieKey = (bn, wc) => `${(bn || "").trim().toLowerCase()}@@${(wc || "").trim().toLowerCase()}`;

  // ===== æç”»é–¢æ•° =====
  function drawBox(points, color, style = 'solid') {
    if (!points || points.length < 4) return;
    overlayCtx.save();
    overlayCtx.lineWidth = 4;
    overlayCtx.setLineDash(style === 'dashed' ? [8, 6] : []);
    overlayCtx.shadowColor = color;
    overlayCtx.shadowBlur = 8;
    overlayCtx.strokeStyle = color;
    overlayCtx.beginPath();
    overlayCtx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      overlayCtx.lineTo(points[i].x, points[i].y);
    }
    overlayCtx.closePath();
    overlayCtx.stroke();
    overlayCtx.restore();
  }

  function showToastNearBox(text, points) {
    if(!points || points.length < 2) return;
    const el = document.createElement("div");
    el.className = "toast";
    el.textContent = text;
    const x = (points[0].x + points[1].x) / 2;
    const y = Math.min(points[0].y, points[1].y);
    const rx = x / DOM.overlay.width * DOM.video.clientWidth;
    const ry = y / DOM.overlay.height * DOM.video.clientHeight;
    el.style.left = rx + "px";
    el.style.top = ry + "px";
    DOM.stack.appendChild(el);
    setTimeout(() => el.remove(), 1200);
  }

  function showBigMessage(text, sub = "") {
    document.querySelectorAll(".bigmsg").forEach(el => el.remove());
    const el = document.createElement("div");
    el.className = "bigmsg";
    el.textContent = text;
    if (sub) {
      const s = document.createElement("span");
      s.className = "sub";
      s.textContent = sub;
      el.appendChild(s);
    }
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1500);
  }

  function fitOverlay() {
    if (!DOM.video.videoWidth || DOM.video.videoWidth === 0) return;
    DOM.overlay.width = DOM.video.videoWidth;
    DOM.overlay.height = DOM.video.videoHeight;
    DOM.overlay.style.width = DOM.video.clientWidth + "px";
    DOM.overlay.style.height = DOM.video.clientHeight + "px";
  }

  // ===== ã‚«ãƒ¡ãƒ©åˆ¶å¾¡ =====
  function stopCam() {
    if (state.rafId) cancelAnimationFrame(state.rafId);
    state.rafId = null;
    if (state.stream) {
      state.stream.getTracks().forEach(t => t.stop());
    }
    state.stream = null;
    DOM.btnStart.disabled = false;
    DOM.btnStop.disabled = true;
    DOM.btnFlipCamera.disabled = true;
    updateStatus("åœæ­¢ä¸­", "ready");
  }

  async function startCam() {
    stopCam();
    clearError();
    try {
      state.stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: state.facingMode },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });
      DOM.video.srcObject = state.stream;
      
      // ãƒ“ãƒ‡ã‚ªã®èª­ã¿è¾¼ã¿ã‚’å¾…ã¤
      await new Promise((resolve) => {
        DOM.video.onloadedmetadata = () => {
          resolve();
        };
      });
      
      await DOM.video.play();
      DOM.btnStart.disabled = true;
      DOM.btnStop.disabled = false;
      DOM.btnFlipCamera.disabled = false;

      if (state.useBarcodeDetector) {
        try { 
          state.detector = new BarcodeDetector({ formats: ["qr_code"] }); 
        } catch { 
          state.useBarcodeDetector = false; 
          state.detector = null; 
        }
      }
      DOM.detectorInfo.textContent = state.useBarcodeDetector ? "BarcodeDetector" : "jsQR";
      fitOverlay();
      tick();
      updateStatus("æ¢ç´¢ä¸­â€¦", "scanning");
    } catch (e) {
      showError(e);
      updateStatus("ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼", "error");
    }
  }

  // ã‚«ãƒ¡ãƒ©åˆ‡æ›¿æ©Ÿèƒ½
  DOM.btnFlipCamera.addEventListener('click', async () => {
    state.facingMode = state.facingMode === 'environment' ? 'user' : 'environment';
    await startCam();
  });

  function holdScan(ms) {
    if (state.holdTimer) clearTimeout(state.holdTimer);
    if (state.rafId) cancelAnimationFrame(state.rafId);
    state.rafId = null;
    updateStatus("ãƒ­ãƒƒã‚¯ä¸­", "ok");
    state.holdTimer = setTimeout(() => {
      if (!state.rafId) tick();
      state.holdTimer = null;
    }, ms);
  }

  // ===== QRæ¤œå‡º =====
  async function detectCombined() {
    if (!DOM.video.videoWidth || DOM.video.videoWidth === 0) return [];
    
    const scale = 0.5; // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ç¸®å°
    const srcW = DOM.video.videoWidth, srcH = DOM.video.videoHeight;
    const w = Math.floor(srcW * scale), h = Math.floor(srcH * scale);

    const tmpCanvas = document.createElement("canvas");
    tmpCanvas.width = w;
    tmpCanvas.height = h;
    const tctx = tmpCanvas.getContext("2d", { willReadFrequently: true });
    tctx.imageSmoothingEnabled = false;
    tctx.drawImage(DOM.video, 0, 0, w, h);

    const allDetections = new Map();

    // BarcodeDetectorã‚’ä½¿ç”¨
    if (state.useBarcodeDetector && state.detector) {
      try {
        const codes = await state.detector.detect(tmpCanvas);
        for (const code of codes) {
          const raw = (code.rawValue || "").trim();
          if (raw && !allDetections.has(raw)) {
            // åº§æ¨™ã‚’å…ƒã®ã‚µã‚¤ã‚ºã«ã‚¹ã‚±ãƒ¼ãƒ«ãƒãƒƒã‚¯
            const scaledPoints = code.cornerPoints.map(p => ({
              x: p.x / scale,
              y: p.y / scale
            }));
            allDetections.set(raw, {
              rawValue: raw,
              cornerPoints: scaledPoints
            });
          }
        }
      } catch (e) { 
        console.warn("BarcodeDetector failed:", e);
        state.useBarcodeDetector = false;
      }
    }

    // jsQRã‚’ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ä½¿ç”¨
    const imgData = tctx.getImageData(0, 0, w, h);
    const maskedData = new Uint8ClampedArray(imgData.data);

    for (let k = 0; k < 5; k++) {
      const hit = jsQR(maskedData, w, h, { inversionAttempts: 'dontInvert' });
      if (!hit) break;

      const raw = (hit.data || "").trim();
      if (raw && !allDetections.has(raw)) {
        // åº§æ¨™ã‚’å…ƒã®ã‚µã‚¤ã‚ºã«ã‚¹ã‚±ãƒ¼ãƒ«ãƒãƒƒã‚¯
        const scaledPoints = [
          hit.location.topLeftCorner,
          hit.location.topRightCorner,
          hit.location.bottomRightCorner,
          hit.location.bottomLeftCorner
        ].map(p => ({
          x: p.x / scale,
          y: p.y / scale
        }));
        
        allDetections.set(raw, {
          rawValue: raw,
          cornerPoints: scaledPoints
        });
      }

      // æ¤œå‡ºã—ãŸQRã‚³ãƒ¼ãƒ‰ã‚’ãƒã‚¹ã‚¯ã—ã¦é‡è¤‡æ¤œå‡ºã‚’é˜²ã
      const { topLeftCorner, bottomRightCorner } = hit.location;
      const minX = Math.max(0, Math.floor(topLeftCorner.x));
      const maxX = Math.min(w, Math.ceil(bottomRightCorner.x));
      const minY = Math.max(0, Math.floor(topLeftCorner.y));
      const maxY = Math.min(h, Math.ceil(bottomRightCorner.y));
      
      for (let y = minY; y < maxY; y++) {
        for (let x = minX; x < maxX; x++) {
          const i = (y * w + x) * 4;
          maskedData[i] = maskedData[i + 1] = maskedData[i + 2] = 255;
        }
      }
    }

    return Array.from(allDetections.values());
  }

  function updateHistory(raw, kind, isMatch) {
    if (state.scanHistory.has(raw)) return;
    if (state.scanHistory.size >= 50) {
      const firstKey = state.scanHistory.keys().next().value;
      state.scanHistory.delete(firstKey);
    }
    state.scanHistory.set(raw, { kind, isMatch, time: new Date() });
  }

  // ===== æ¤œå‡ºçµæœå‡¦ç† =====
  function applyDetections(detections) {
    let anyMatch = false;
    let anyLocMatch = false;
    
    // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’ã‚¯ãƒªã‚¢
    overlayCtx.clearRect(0, 0, DOM.overlay.width, DOM.overlay.height);

    for (const d of detections) {
      const raw = (d.rawValue || "").trim();
      if (!raw) continue;

      const kind = classify(raw);
      const pts = d.cornerPoints;

      if (kind === 'die') {
        const p = parseDie(raw);
        const key = p ? dieKey(p.bn, p.wc) : "";
        const isMatch = key && key === state.targetKey;
        anyMatch = anyMatch || isMatch;

        if (isMatch) {
          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸€è‡´ - é’æ 
          drawBox(pts, CONFIG.colors.ok, 'solid');
          showToastNearBox("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸€è‡´ï¼", pts);
        } else {
          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸ä¸€è‡´ - èµ¤æ 
          drawBox(pts, CONFIG.colors.ng, 'dashed');
          const label = p ? `ä¸ä¸€è‡´ [${p.bn}/${p.wc}]` : "ä¸æ˜ãªå½¢å¼";
          showToastNearBox(label, pts);
        }

        updateHistory(raw, 'die', isMatch);

        if (isMatch && !state.isLocked) {
          state.isLocked = true;
          confirmationBeep();
          if (navigator.vibrate) navigator.vibrate(150);
          showBigMessage("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ", "ä¸€è‡´ã—ãŸQRã‚’é’æ ã§å¼·èª¿è¡¨ç¤º");
          speakFoundOnce(state.currentTarget.wn || (p && p.wn) || "");
          holdScan(CONFIG.holdDuration);
          setTimeout(() => { state.isLocked = false; }, CONFIG.lockCooldown);
        }

      } else if (kind === 'loc') {
        const locData = parseLoc(raw);
        const isLocMatch = state.currentShelf && locData && 
                          locData.loc.toLowerCase() === state.currentShelf.toLowerCase();
        anyLocMatch = anyLocMatch || isLocMatch;

        if (isLocMatch) {
          // æ£šä¸€è‡´ - ç·‘æ 
          drawBox(pts, CONFIG.colors.loc, 'solid');
          showToastNearBox("ç›®çš„ã®æ£šã§ã™", pts);
          speakTargetLocFound();
        } else {
          // æ£šä¸ä¸€è‡´ - èµ¤æ 
          drawBox(pts, CONFIG.colors.ng, 'dashed');
          const label = locData ? `æ£šé•ã„ [${locData.loc}]` : "ä¸æ˜ãªæ£šQR";
          showToastNearBox(label, pts);
        }

        updateHistory(raw, 'loc', isLocMatch);

      } else if (kind === 'order') {
        const od = parseOrderPlain(raw);
        if (od && (od.bn || od.wc)) {
          const newKey = dieKey(od.bn, od.wc);
          const now = performance.now();
          const sameAsBefore = (newKey === state.__lastOrderKey);
          const stillCooling = (now - state.__orderSetAt) < CONFIG.orderResetCooldownMs;

          // ä½œæ¥­æŒ‡ç¤ºQR - ã‚ªãƒ¬ãƒ³ã‚¸æ 
          drawBox(pts, CONFIG.colors.info, 'solid');
          showToastNearBox("ä½œæ¥­æŒ‡ç¤ºQR", pts);

          if (!sameAsBefore || !stillCooling || newKey !== state.targetKey) {
            state.currentTarget = { book: od.bn || "", wc: od.wc || "", wn: "" };
            state.targetKey = newKey;
            state.__lastOrderKey = newKey;
            state.__orderSetAt = now;

            // UIæ›´æ–°
            DOM.tgtBN.textContent = state.currentTarget.book || "-";
            DOM.tgtWC.textContent = state.currentTarget.wc || "-";
            DOM.tgtWN.textContent = "";

            showBigMessage("ä½œæ¥­æŒ‡ç¤ºQRã‚’èª­ã¿å–ã‚Š", "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®šã—ã¾ã—ãŸ");
            speakLineOnce(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ ${state.currentTarget.book} ${state.currentTarget.wc} ã«è¨­å®š`, { cooldown: 2500 });

            // æ£šæƒ…å ±ã‚’è‡ªå‹•å–å¾—
            if (!state.currentShelf) {
              maybeUpdateShelfFromSheets(state.currentTarget.book, state.currentTarget.wc);
            }

            holdScan(800);
          }
        } else {
          drawBox(pts, CONFIG.colors.ng, 'dashed');
          showToastNearBox("ä¸æ˜ãªä½œæ¥­æŒ‡ç¤ºQR", pts);
        }

        updateHistory(raw, 'order', !!od);

      } else {
        // ãã®ä»–ã®QR - èµ¤æ 
        drawBox(pts, CONFIG.colors.ng, 'dashed');
        showToastNearBox("å¯¾è±¡å¤–ã®QR", pts);
        updateHistory(raw, 'other', false);
      }
    }

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
    if (!state.holdTimer) {
      let msg = "æ¢ç´¢ä¸­...";
      let statusType = "scanning";

      if (detections.length > 0) {
        if (anyMatch) {
          msg = "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç™ºè¦‹ï¼";
          statusType = "ok";
        } else if (anyLocMatch) {
          msg = "ç›®çš„ã®æ£šã‚’ç™ºè¦‹";
          statusType = "loc";
        } else {
          msg = `${detections.length}ä»¶ã®QRã‚’æ¤œå‡º`;
          statusType = "scanning";
        }
      }
      updateStatus(msg, statusType);
    }
  }

  async function tick() {
    if (!state.stream) return;
    if (DOM.video.readyState === DOM.video.HAVE_ENOUGH_DATA) {
      fitOverlay();
      try {
        const detections = await detectCombined();
        applyDetections(detections);
      } catch (error) {
        console.error('Detection error:', error);
      }
    }
    state.rafId = requestAnimationFrame(tick);
  }

  // ===== Google Sheetsã‹ã‚‰æ£šæƒ…å ±å–å¾— =====
  let __lastShelfFetchKey = '';
  async function maybeUpdateShelfFromSheets(book, wc){
    if(!book || !wc) return;
    const key = (book+'@@'+wc).toLowerCase();
    if(__lastShelfFetchKey === key) return;
    if(state.currentShelf) return;

    __lastShelfFetchKey = key;
    DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±å–å¾—ä¸­â€¦ï¼‰';

    try{
      // ç°¡æ˜“çš„ãªå®Ÿè£… - å®Ÿéš›ã®APIå‘¼ã³å‡ºã—ã¯ç’°å¢ƒã«åˆã‚ã›ã¦èª¿æ•´
      const loc = await mockFetchLocation(book, wc);
      if(loc){
        state.currentShelf = loc;
        DOM.currentShelf.textContent = state.currentShelf;
      }else{
        DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±ãªã—ï¼‰';
      }
    }catch(e){
      console.warn('Locationå–å¾—å¤±æ•—:', e);
      DOM.currentShelf.textContent = 'ï¼ˆå–å¾—å¤±æ•—ï¼‰';
    }
  }

  // ãƒ¢ãƒƒã‚¯é–¢æ•° - å®Ÿéš›ã®å®Ÿè£…ã§ã¯APIå‘¼ã³å‡ºã—ã«ç½®ãæ›ãˆ
  async function mockFetchLocation(book, wc) {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã“ã“ã§APIã‚’å‘¼ã³å‡ºã™
    await new Promise(resolve => setTimeout(resolve, 100));
    const mockData = {
      'ta@@2356': 'A-12',
      'ko@@1234': 'B-08', 
      'yo@@5678': 'C-15'
    };
    return mockData[`${book.toLowerCase()}@@${wc}`] || null;
  }

  // ===== æ‰‹å‹•ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š =====
  function setTargetByManual(book, wc) {
    book = (book || '').trim();
    wc   = (wc   || '').trim();
    if (!book || !wc) {
      alert('book ã¨ wc ã‚’å…¥åŠ›ï¼ˆé¸æŠï¼‰ã—ã¦ãã ã•ã„');
      return;
    }

    state.currentTarget = { book, wc, wn: '' };
    state.targetKey = dieKey(book, wc);

    DOM.tgtBN.textContent = book;
    DOM.tgtWC.textContent = wc;
    DOM.tgtWN.textContent = '';

    updateStatus('ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š', 'ok');
    showBigMessage('æ‰‹å‹•ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š', `Book=${book} / WC=${wc}`);
    speakLineOnce(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ ${book} ${wc} ã«è¨­å®š`);

    if (!state.currentShelf) {
      maybeUpdateShelfFromSheets(book, wc);
    }
  }

  // ===== å±¥æ­´è¡¨ç¤º =====
  function showHistoryModal() {
    DOM.historyList.innerHTML = '';
    if(state.scanHistory.size === 0){
      DOM.historyList.innerHTML = '<li style="text-align:center;padding:20px;color:var(--sub);">ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>';
    } else {
      const sortedHistory = Array.from(state.scanHistory.entries()).reverse();
      for (const [raw, data] of sortedHistory) {
        const li = document.createElement('li');
        let status = '';
        let icon = '';
        if (data.kind === 'die') {
          status = data.isMatch ? 'ä¸€è‡´ (å‹)' : 'ä¸ä¸€è‡´ (å‹)';
          icon = data.isMatch ? 'âœ…' : 'âŒ';
        } else if (data.kind === 'loc') {
          status = data.isMatch ? 'ä¸€è‡´ (æ£š)' : 'ä¸ä¸€è‡´ (æ£š)';
          icon = data.isMatch ? 'âœ…' : 'âŒ';
        } else if (data.kind === 'order') {
          status = data.isMatch ? 'ä½œæ¥­æŒ‡ç¤º èª­ã¿å–ã‚Š' : 'ä½œæ¥­æŒ‡ç¤º å½¢å¼ä¸æ˜';
          icon = data.isMatch ? 'ğŸ“' : 'â“';
        } else {
          status = 'ãã®ä»–';
          icon = 'â“';
        }
        
        const time = data.time.toLocaleTimeString();
        li.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px;">
            <div style="flex:1;">
              <div style="font-weight:600;margin-bottom:4px;">${icon} ${status}</div>
              <div style="font-size:12px;color:var(--sub);word-break:break-all;">${raw}</div>
            </div>
            <div style="font-size:12px;color:var(--sub);white-space:nowrap;">${time}</div>
          </div>
        `;
        DOM.historyList.appendChild(li);
      }
    }
    DOM.historyModal.style.display = 'block';
  }

  // ===== ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ =====
  DOM.btnStart.addEventListener("click", () => {
    initTTS();
    unlockTTS();
    startCam();
  });
  DOM.btnStop.addEventListener("click", stopCam);
  DOM.btnShowHistory.addEventListener("click", showHistoryModal);
  DOM.closeModal.addEventListener("click", () => DOM.historyModal.style.display = 'none');
  window.addEventListener("click", (event) => {
    if (event.target == DOM.historyModal) DOM.historyModal.style.display = "none";
  });
  
  DOM.fileTest.addEventListener("change", async (ev) => {
    const file = ev.target.files?.[0];
    if (!file) return;
    const img = new Image();
    img.onload = async () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width; canvas.height = img.height;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0);
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // jsQRã§ç”»åƒã‹ã‚‰QRã‚³ãƒ¼ãƒ‰ã‚’æ¤œå‡º
      const hit = jsQR(imgData.data, imgData.width, imgData.height, { inversionAttempts: 'dontInvert' });
      if (hit) {
        const hits = [{
          rawValue: hit.data,
          cornerPoints: [
            hit.location.topLeftCorner,
            hit.location.topRightCorner,
            hit.location.bottomRightCorner,
            hit.location.bottomLeftCorner
          ]
        }];
        DOM.overlay.width = img.width;
        DOM.overlay.height = img.height;
        applyDetections(hits);
        updateStatus(`ç”»åƒãƒ†ã‚¹ãƒˆ: QRã‚’æ¤œå‡º`, 'scanning');
      } else {
        updateStatus(`ç”»åƒãƒ†ã‚¹ãƒˆ: QRæœªæ¤œå‡º`, 'error');
      }
      ev.target.value = "";
    };
    img.src = URL.createObjectURL(file);
  });
  
  DOM.btnSetTarget.addEventListener('click', () => {
    const book = DOM.inBook?.value || '';
    const wc   = DOM.inWc?.value   || '';
    setTargetByManual(book, wc);
  });

  // ===== åˆæœŸåŒ– =====
  function initialize() {
    const params = new URLSearchParams(location.search);
    state.currentTarget = {
      book: (params.get("book") || "").trim(),
      wc: (params.get("wc") || "").trim(),
      wn: (params.get("wn") || "").trim()
    };

    if (state.currentTarget.book && state.currentTarget.wc) {
      DOM.tgtBN.textContent = state.currentTarget.book;
      DOM.tgtWC.textContent = state.currentTarget.wc;
      DOM.tgtWN.textContent = state.currentTarget.wn;
      state.targetKey = dieKey(state.currentTarget.book, state.currentTarget.wc);
      updateStatus("æº–å‚™å®Œäº†", "ready");
      
      // æ£šæƒ…å ±ã‚’è¨­å®š
      const locParam = (params.get("loc") || "").trim();
      if(locParam){
        state.currentShelf = locParam;
        DOM.currentShelf.textContent = state.currentShelf;
      } else {
        maybeUpdateShelfFromSheets(state.currentTarget.book, state.currentTarget.wc);
      }
    } else {
      updateStatus("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæœªè¨­å®š", "scanning");
    }

    // URLã® book/wc ã‚’æ‰‹å…¥åŠ›UIã«ã‚‚åæ˜ 
    if (DOM.inBook && state.currentTarget.book) {
      const opt = Array.from(DOM.inBook.options).find(o => 
        (o.value || '').toLowerCase() === state.currentTarget.book.toLowerCase()
      );
      if (opt) DOM.inBook.value = opt.value;
    }
    if (DOM.inWc && state.currentTarget.wc) {
      DOM.inWc.value = state.currentTarget.wc;
    }

    // æˆ»ã‚‹ãƒœã‚¿ãƒ³
    document.querySelector('.back-btn').addEventListener('click', function() {
      if (state.stream) stopCam();
      history.back();
    });
  }

  initialize();
});
</script>
</body>
</html>