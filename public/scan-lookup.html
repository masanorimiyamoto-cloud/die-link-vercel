<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>æŠœå‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ deep</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --ok: #1c7ed6;      /* ä¸€è‡´=é’ */
    --ng: #e03131;      /* ä¸ä¸€è‡´=èµ¤ */
    --loc: #2b8a3e;     /* LOC=ç·‘ */
    --info: #f59f00;    /* æƒ…å ±=ã‚ªãƒ¬ãƒ³ã‚¸ */
    --bd: #dee2e6; --tx: #212529; --sub: #6c757d;
    --bg-ok: #e7f5ff; --bg-ng: #fff5f5; --bg-loc: #e6fcf5;
  }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 0; padding: 12px; color: var(--tx); background: #f8f9fa; }
  h3, h4 { margin: 0 0 8px 0; }
  .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
  .panel { flex: 1 1 360px; min-width: 320px; }
  .card { background: #fff; border: 1px solid var(--bd); border-radius: 12px; padding: 12px; margin-bottom: 12px; }
  video { width: 100%; max-width: 520px; border-radius: 12px; background: #000; display: block; }
  .stack { position: relative; max-width: 520px; border: 1px solid var(--bd); border-radius: 12px; overflow: hidden; }
  canvas { position: absolute; inset: 0; pointer-events: none; }
  .controls { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; align-items: center; }
  button { padding: 10px 16px; border-radius: 8px; border: 1px solid var(--bd); background: #fff; cursor: pointer; font-size: 14px; transition: background-color 0.2s; }
  button:disabled { cursor: not-allowed; opacity: 0.6; }
  button.primary { background: var(--ok); color: #fff; border-color: var(--ok); }
  button:hover:not(:disabled) { background-color: #f1f3f5; }
  button.primary:hover:not(:disabled) { background: #339af0; }
  .badge { display: inline-block; border-radius: 6px; padding: 4px 8px; font-size: 12px; border: 1px solid var(--bd); background: #f1f3f5; }
  .target-info b { font-size: 1.1em; }
  .chip { display: inline-block; padding: 2px 8px; border-radius: 99px; font-size: 12px; font-weight: 500; }
  .chip.ok { background: var(--bg-ok); color: var(--ok); border: 1px solid #a5d8ff; }
  .chip.ng { background: var(--bg-ng); color: var(--ng); border: 1px solid #ffc9c9; }
  .chip.loc { background: var(--bg-loc); color: var(--loc); border: 1px solid #96f2d7; }
  .muted { color: var(--sub); font-size: 14px; }
  .toast { position: absolute; padding: 8px 12px; background: #000c; color: #fff; border-radius: 8px; font-size: 14px; transform: translate(-50%, -150%); pointer-events: none; animation: fade-out 1.2s forwards; }
  @keyframes fade-out { from { opacity: 1; } to { opacity: 0; } }
  .legend { font-size: 12px; color: #555; margin-top: 8px; }

  .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
  .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid var(--bd); width: 80%; max-width: 600px; border-radius: 12px; }
  .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--bd); padding-bottom: 10px; margin-bottom: 10px; }
  .close-button { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
  #historyList li { padding: 6px 0; border-bottom: 1px solid #eee; font-size: 14px; }

  .bigmsg {
    position: fixed;
    left: 50%;
    top: 18%;
    transform: translateX(-50%);
    z-index: 1200;
    background: rgba(28, 126, 214, 0.95);
    color: #fff;
    padding: 16px 22px;
    border-radius: 12px;
    font-size: clamp(18px, 3.2vw, 26px);
    box-shadow: 0 8px 24px rgba(0,0,0,.2);
    letter-spacing: .02em;
    text-align: center;
    pointer-events: none;
    animation: bigmsg-fade 1.2s ease-out forwards;
  }
  .bigmsg .sub { display:block; font-size: .8em; opacity: .9; margin-top: 2px; }
  @keyframes bigmsg-fade {
    0%   { opacity: 0; transform: translateX(-50%) translateY(-8px); }
    10%  { opacity: 1; transform: translateX(-50%) translateY(0); }
    80%  { opacity: 1; }
    100% { opacity: 0; transform: translateX(-50%) translateY(-8px); }
  }

  /* ===== ğŸ¨ UI/UX æ”¹è‰¯ã‚¹ã‚¿ã‚¤ãƒ« (scan-lookup.html) ===== */
  :root { --tx:#212529; --sub:#5a636c; --bg:#f4f7f9; --bd:#e9ecef; --ok-soft:var(--bg-ok,#e7f5ff); --ng-soft:var(--bg-ng,#fff5f5); --loc-soft:var(--bg-loc,#e6fcf5); --info-soft:#fff9e6; }
  html, body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; background: var(--bg); }
  h4 { font-size: 15px; font-weight: 600; color: var(--tx); padding-bottom: 8px; border-bottom: 1px solid var(--bd); margin-top: 2px; letter-spacing: .01em; }

  .card { padding: 14px 18px; border: none; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,.06), 0 1px 3px rgba(0,0,0,.04); transition: box-shadow .2s ease; overflow: hidden; }
  .card:hover { box-shadow: 0 6px 16px rgba(0,0,0,.07), 0 2px 6px rgba(0,0,0,.04); }

  .target-info b { font-size: 1.4em; color: var(--ok); font-weight: 700; margin: 0 2px; }
  .target-info { font-size: 15px; line-height: 1.4; padding-top: 4px; }
  #tgtWN { font-size: 14px; color: var(--sub); font-weight: 500; }

  #currentShelf { font-size: 1.3em; font-weight: 700; margin-top: 4px; }
  #currentShelf.chip.loc { padding: 8px 12px; font-size: 1.3em; margin: 4px -18px -14px -18px; border-radius: 0 0 12px 12px; text-align: center; border: none; border-top: 1px solid #96f2d7; }
  #currentShelf.muted { font-size: 14px; font-weight: 500; color: var(--sub); margin: 4px 0 0 0; }

  button { border-radius: 10px; font-weight: 600; transition: all .2s ease; }
  button:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,.05); }
  button.primary:not(:disabled):hover { background: #339af0; box-shadow: 0 4px 10px rgba(28,126,214,.25); }
  .badge { background: #fff; border-color: #dbe4f0; font-weight: 500; padding: 6px 10px; border-radius: 8px; }
  #scanStatus.badge { padding: 6px 12px; font-size: 13px; font-weight: 600; }
  #scanStatus.badge.chip.ok { background: var(--ok-soft); color: var(--ok); border-color: #a5d8ff; }
  #scanStatus.badge.chip.ng { background: var(--ng-soft); color: var(--ng); border-color: #ffc9c9; }
  #scanStatus.badge.chip.loc { background: var(--loc-soft); color: var(--loc); border-color: #96f2d7; }
  #scanStatus.badge.chip.info { background: var(--info-soft); color: #c67c00; border-color: #ffe08c; }

  .stack { border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,.08); }
  video { border-radius: 12px; }

  #error { margin-top: 10px; padding: 10px 14px; border-radius: 10px; background: var(--ng-soft); color: #b00020; border: 1px solid #ffc9c9; font-weight: 500; white-space: pre-wrap; display: none; }
  #error:not(:empty) { display: block; }

  /* å…¥åŠ›è¡Œ */
  .rowbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .rowbar input[type=text] { padding: 8px 10px; border:1px solid var(--bd); border-radius:10px; font-size:14px; min-width:10ch; }
  .mutetiny { color:#868e96; font-size:12px; }
</style>
</head>
<body>
  <div class="row">
    <div class="panel">
      <div class="stack" id="stack">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="controls">
        <span id="scanStatus" class="badge">å¾…æ©Ÿä¸­</span>
        <label class="badge" style="cursor:pointer">ç”»åƒãƒ†ã‚¹ãƒˆ<input id="fileTest" type="file" accept="image/*" style="display:none" /></label>
        <span id="detectorInfo" class="badge"></span>
      </div>
      <div id="error" class="muted" style="color:#b00;white-space:pre-wrap;margin-top:8px;"></div>
    </div>

    <div class="panel">
      <div class="card">
        <h4>ğŸ¯ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ</h4>
        <div class="target-info">
          Book: <b id="tgtBN">-</b> | WC: <b id="tgtWC">-</b><br>
          <span id="tgtWN" class="muted"></span>
        </div>
      </div>

      <div class="card">
        <h4>âŒ¨ï¸ ç›´æ¥å…¥åŠ›ï¼ˆBook / WCï¼‰</h4>
        <div class="rowbar" style="margin:6px 0 8px">
          <label>Book: <input type="text" id="inBook" placeholder="ä¾‹: Ta" inputmode="latin" autocomplete="off" /></label>
          <label>WC: <input type="text" id="inWc" placeholder="ä¾‹: 2356" inputmode="numeric" autocomplete="off" /></label>
          <button id="btnApply" class="primary">è¨­å®š</button>
          <button id="btnFill">ç¾åœ¨ã®å€¤ã‚’å…¥ã‚Œã‚‹</button>
          <button id="btnClear">ã‚¯ãƒªã‚¢</button>
        </div>
        <div class="mutetiny">â€» è¨­å®šã™ã‚‹ã¨ã€Œã‚¿ãƒ¼ã‚²ãƒƒãƒˆã€ãŒæ›´æ–°ã•ã‚Œã€ã‚¹ã‚­ãƒ£ãƒ³ä¸€è‡´åˆ¤å®šï¼ˆé’æ ï¼‰ãŒã“ã®çµ„ã¿åˆã‚ã›ã«åˆ‡ã‚Šæ›¿ã‚ã‚Šã¾ã™ã€‚URLã« <code>?book=...&wc=...</code> ãŒç„¡ã„å ´åˆã¯ã€Sheets ã‹ã‚‰æ£šæƒ…å ±(Location)ã‚’è‡ªå‹•å–å¾—ã—ã¾ã™ã€‚</div>
      </div>

      <div class="card">
        <h4> æ£š æ¢ã™ã¹ãæ£š</h4>
        <div id="currentShelf" class="muted">ï¼ˆURLæœªæŒ‡å®šï¼‰</div>
      </div>
      <div class="rowbar" style="margin-top:8px">
        <label>æ£š(æ‰‹å‹•): <input type="text" id="inLoc" placeholder="ä¾‹: A-3-2" autocomplete="off" /></label>
        <button id="btnLocSet" class="primary">æ£šã‚’è¨­å®š</button>
        <button id="btnLocClear">æ£šã‚¯ãƒªã‚¢</button>
      </div>
      <div class="mutetiny">â€» è‡ªå‹•å–å¾—ã§ããªã„å ´åˆã¯ã“ã“ã§ç›´æ¥è¨­å®šã§ãã¾ã™ã€‚</div>

      <div class="card">
        <h4>âš™ï¸ æ“ä½œ</h4>
        <div class="controls">
          <button id="btnStart" class="primary">ã‚«ãƒ¡ãƒ©é–‹å§‹</button>
          <button id="btnStop" disabled>åœæ­¢</button>
          <button id="btnHistory">ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´</button>
        </div>
        <div class="legend">
          <span class="chip ok">ä¸€è‡´(å‹)</span>
          <span class="chip loc">ä¸€è‡´(æ£š)</span>
          <span class="chip ng">ä¸ä¸€è‡´</span>
        </div>
      </div>

      <div class="card">
        <h4>ğŸ’¡ ãƒ’ãƒ³ãƒˆ</h4>
        <div class="muted" style="font-size:13px;">
          ãƒ»URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ <code>?book=...&wc=...&loc=...</code> ã§æ¢ã™æŠœå‹ã¨æ£šã‚’æŒ‡å®šã—ã¾ã™ã€‚<br>
          ãƒ»ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ä¸€è‡´ã—ãŸQRã¯<strong style="color:var(--ok)">é’æ </strong>ã¨éŸ³ã¨æŒ¯å‹•ã§ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ã€‚<br>
          ãƒ»ç›®çš„ã®æ£šã¨ä¸€è‡´ã—ãŸQRã¯<strong style="color:var(--loc)">ç·‘æ </strong>ã§ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ã€‚
        </div>
      </div>
    </div>
  </div>

  <div id="historyModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h4>ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´</h4>
        <span id="closeModal" class="close-button">&times;</span>
      </div>
      <ul id="historyList"></ul>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" crossorigin="anonymous"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const DOM = {
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
      stack: document.getElementById('stack'),
      btnStart: document.getElementById('btnStart'),
      btnStop: document.getElementById('btnStop'),
      btnHistory: document.getElementById('btnHistory'),
      tgtBN: document.getElementById('tgtBN'),
      tgtWC: document.getElementById('tgtWC'),
      tgtWN: document.getElementById('tgtWN'),
      currentShelf: document.getElementById('currentShelf'),
      scanStatus: document.getElementById('scanStatus'),
      detectorInfo: document.getElementById('detectorInfo'),
      error: document.getElementById('error'),
      fileTest: document.getElementById('fileTest'),
      historyModal: document.getElementById('historyModal'),
      historyList: document.getElementById('historyList'),
      closeModal: document.getElementById('closeModal'),
      // è¿½åŠ : ç›´æ¥å…¥åŠ›UI
      inBook: document.getElementById('inBook'),
      inWc: document.getElementById('inWc'),
      btnApply: document.getElementById('btnApply'),
      btnFill: document.getElementById('btnFill'),
      btnClear: document.getElementById('btnClear'),
      inLoc: document.getElementById('inLoc'),
      btnLocSet: document.getElementById('btnLocSet'),
      btnLocClear: document.getElementById('btnLocClear'),

    };

    const overlayCtx = DOM.overlay.getContext('2d', { willReadFrequently: true });

    const state = {
      stream: null,
      rafId: null,
      detector: null,
      useBarcodeDetector: ('BarcodeDetector' in window),
      isLocked: false,
      holdTimer: null,
      currentTarget: {},
      targetKey: '',
      currentShelf: null,
      scanHistory: new Map(),
      __lastOrderKey: '',
      __orderSetAt: 0,
      csrf: ''   // â† CSRFãƒˆãƒ¼ã‚¯ãƒ³
    };

    /* ====== CSRFï¼ˆ/api/die-check ç”¨ï¼‰ ====== */
    const isLocal = () => location.protocol==='http:' && /localhost|127\.0\.0\.1/.test(location.host);
    const readCookie = (name) => {
      const m = document.cookie.match(new RegExp('(?:^|; )'+name.replace(/[-/\\^$*+?.()|[\\]{}]/g,'\\$&')+'=([^;]*)'));
      return m ? decodeURIComponent(m[1]) : '';
    };
    async function requestSession(){
      const url = isLocal() ? '/api/session?dev=1' : '/api/session';
      await fetch(url, { method:'GET', credentials:'same-origin', cache:'no-store' }).catch(()=>{});
    }
    async function ensureCsrf(){
      let t = readCookie('xcsrf');
      if(!t){ await requestSession(); t = readCookie('xcsrf'); }
      if(!t) throw new Error('CSRF Cookie(xcsrf)ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
      state.csrf = t;
    }

    // Google Sheets ã® Location ã‚’ /api/die-checkï¼ˆJSONï¼‰ã‹ã‚‰å–å¾—ã—ã¦åæ˜ 
    let __lastShelfFetchKey = '';
    async function maybeUpdateShelfFromSheets(book, wc){
      if(!book || !wc) return;
      const key = (book+'@@'+wc).toLowerCase();
      if(__lastShelfFetchKey === key) return;     // äºŒé‡å–å¾—é˜²æ­¢
      if(state.currentShelf) return;              // æ—¢ã«URL/æ‰‹å‹•ã§å…¥ã£ã¦ã„ã‚Œã°ä¸è¦
      __lastShelfFetchKey = key;

      // å–å¾—ä¸­ã®è¡¨ç¤ºã‚’â€œå¿…ãšâ€å‡ºã™
      DOM.currentShelf.textContent = 'ï¼ˆSheetsã‹ã‚‰å–å¾—ä¸­â€¦ï¼‰';
      DOM.currentShelf.className = 'muted';

      // 1) å®‰å…¨ã«POST â†’ 2) å¤±æ•—ã—ãŸã‚‰GETãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      async function fetchByPost(){
        if(!state.csrf){
          try { await ensureCsrf(); } catch(e){ throw e; }
        }
        const r = await fetch('/api/die-check', {
          method:'POST',
          credentials:'same-origin',
          headers:{ 'Content-Type':'application/json', 'X-CSRF': state.csrf },
          body: JSON.stringify({ book, wc, json:true, limit: 1 })
        });
        const txt = await r.text();
        let j = {};
        try { j = JSON.parse(txt); } catch { throw new Error(`JSON Parse error: ${txt.slice(0,200)}`); }
        if(!r.ok || j.ok!==true) throw new Error(j?.error || `HTTP ${r.status}`);
        return j;
      }
      async function fetchByGet(){
        const qs = new URLSearchParams({ book, wc, json:'1', limit:'1' });
        const r = await fetch(`/api/die-check?${qs.toString()}`, { method:'GET', cache:'no-store' });
        const txt = await r.text();
        let j = {};
        try { j = JSON.parse(txt); } catch { throw new Error(`JSON Parse error(GET): ${txt.slice(0,200)}`); }
        return j;
      }

      // å–å¾—ã—ãŸJSONã‹ã‚‰ Location ã‚’é ‘å¥ã«æŠœãï¼ˆè¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³å¯¾å¿œï¼‰
      function pickLocation(j){
        // æ—¢å®š: j.gs.Location
        if(j && j.gs && j.gs.Location) return String(j.gs.Location).trim();

        // ãƒ¬ã‚³ãƒ¼ãƒ‰é…åˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¾‹: j.rows[0].Location / j.records[0].fields.Locationï¼‰
        const cands = [];
        if (Array.isArray(j?.rows) && j.rows[0]) cands.push(j.rows[0].Location, j.rows[0].loc);
        if (Array.isArray(j?.records) && j.records[0]) {
          const f = j.records[0].fields || {};
          cands.push(f.Location, f.loc);
        }
        // ãƒã‚¹ãƒˆå¤šæ§˜æ€§
        cands.push(j?.Location, j?.loc, j?.result?.gs?.Location);
        const hit = cands.find(v => typeof v === 'string' && v.trim().length>0);
        return hit ? String(hit).trim() : '';
      }

      try{
        let j;
        try {
          j = await fetchByPost();
        } catch (ePost) {
          // POSTãŒãƒ€ãƒ¡ã§ã‚‚GETã§ç²˜ã‚‹
          try {
            j = await fetchByGet();
          } catch (eGet) {
            throw ePost || eGet;
          }
        }
        const loc = pickLocation(j);
        if(loc){
          state.currentShelf = loc;
          DOM.currentShelf.textContent = state.currentShelf;
          DOM.currentShelf.className = 'chip loc';
        } else {
          DOM.currentShelf.textContent = 'ï¼ˆGoogle Sheets ã«æ£šæƒ…å ±ãªã—ï¼‰';
          DOM.currentShelf.className = 'muted';
        }
      }catch(e){
        console.warn('Locationå–å¾—å¤±æ•—:', e);
        DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±ã®å–å¾—ã«å¤±æ•—ï¼‰';
        DOM.currentShelf.className = 'muted';
      }
    }


    /* ====== éŸ³å£°èª­ã¿ä¸Šã’ ====== */
    let __jpVoices = [];
    let __lastSpeak = 0;
    let __lastLocSpeak = 0;
    const __speakCooldownMs = 1500;
    const __locSpeakCooldownMs = 3000;

    function initTTS() {
      if (!('speechSynthesis' in window)) return;
      const synth = window.speechSynthesis;
      function loadVoices() {
        const voices = synth.getVoices();
        __jpVoices = voices
          .filter(v => /ja|jpn|æ—¥æœ¬èª/i.test(v.lang) || /æ—¥æœ¬èª/i.test(v.name))
          .sort((a,b) => {
            const pref = ['Google æ—¥æœ¬èª', 'Kyoko', 'Otoya'];
            const ia = pref.findIndex(p => (a.name||'').includes(p));
            const ib = pref.findIndex(p => (b.name||'').includes(p));
            return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
          });
      }
      loadVoices();
      synth.onvoiceschanged = loadVoices;
    }
    const punct = s => String(s||"").replace(/\s+/g, ' ').trim();
    function unlockTTS() {
      if (!('speechSynthesis' in window)) return;
      const u = new SpeechSynthesisUtterance(' ');
      u.lang = 'ja-JP'; u.volume = 0; u.rate = 1; u.pitch = 1;
      try { window.speechSynthesis.speak(u); } catch {}
    }
    function speakAfterReady(utterance) {
      if (!('speechSynthesis' in window)) return;
      const synth = window.speechSynthesis;
      const trySpeak = (retries = 2) => {
        try { synth.cancel(); } catch {}
        try { synth.speak(utterance); }
        catch (e) {
          if (retries > 0) setTimeout(() => trySpeak(retries - 1), 200);
        }
      };
      trySpeak();
    }
    function speakFoundOnce(workName) {
      if (!('speechSynthesis' in window)) return;
      const now = performance.now();
      if (now - __lastSpeak < __speakCooldownMs) return;
      __lastSpeak = now;
      const hasWN = !!workName && String(workName).trim().length > 0;
      const text = hasWN ? `ãŠæ¢ã—ã®å‹ã€${workName}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚` : `ãŠæ¢ã—ã®å‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚`;
      const u = new SpeechSynthesisUtterance(punct(text));
      u.lang='ja-JP';u.rate=1.0;u.pitch=1.1;u.volume=1.0;
      if (__jpVoices.length>0) u.voice=__jpVoices[0];
      speakAfterReady(u);
    }
    function speakTargetLocFound() {
      if (!('speechSynthesis' in window)) return;
      const now = performance.now();
      if (now - __lastLocSpeak < __locSpeakCooldownMs) return;
      __lastLocSpeak = now;
      const u = new SpeechSynthesisUtterance("ç›®çš„ã®æ£šã§ã™");
      u.lang='ja-JP';u.rate=1.0;u.pitch=1.1;u.volume=0.8;
      if (__jpVoices.length>0) u.voice=__jpVoices[0];
      speakAfterReady(u);
    }
    let __lastGenericSpeak = 0;
    function speakLineOnce(text, {rate=1.08, pitch=1.2, cooldown=1200} = {}) {
      if (!('speechSynthesis' in window)) return;
      const now = performance.now();
      if (now - __lastGenericSpeak < cooldown) return;
      __lastGenericSpeak = now;
      const u = new SpeechSynthesisUtterance(punct(text));
      u.lang='ja-JP';u.rate=rate;u.pitch=pitch;u.volume=1.0;
      if (__jpVoices.length>0) u.voice=__jpVoices[0];
      speakAfterReady(u);
    }

    function cssVarOr(name, fallback) {
      const v = getComputedStyle(document.documentElement).getPropertyValue(name);
      const s = (v || '').trim();
      return s || fallback;
    }
    const CONFIG = {
      colors: {
        ok: cssVarOr('--ok', '#1c7ed6'),
        ng: cssVarOr('--ng', '#e03131'),
        loc: cssVarOr('--loc', '#2b8a3e'),
        info: cssVarOr('--info', '#f59f00'),
      },
      holdDuration: 3000,
      lockCooldown: 700,
      orderResetCooldownMs: 2000,
    };

    const confirmationBeep = (() => {
      let audioCtx;
      const play = () => {
        try {
          audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
          const t0 = audioCtx.currentTime;
          const osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(600, t0);
          osc.frequency.exponentialRampToValueAtTime(1200, t0 + 0.1);
          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(0.0001, t0);
          gain.gain.exponentialRampToValueAtTime(0.4, t0 + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.2);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(t0);
          osc.stop(t0 + 0.25);
        } catch {}
      };
      return play;
    })();

    const normalizeHyphen = s => (s || "").replace(/[â€-â€’â€“â€”â€•ãƒ¼âˆ’]/g, "-");

    /* === ç¨®åˆ¥åˆ¤å®š === */
    const classify = (raw) => {
      const text = normalizeHyphen((raw || "").trim());
      if (/^loc-/i.test(text)) return "loc";
      try { const url = new URL(text); if (url.searchParams.has("loc")) return "loc"; } catch {}
      if (/^die-/i.test(text)) return "die";
      try { const url = new URL(text); if (url.searchParams.has("book") || url.searchParams.has("wc")) return "die"; } catch {}
      if (/^order-/i.test(text)) return "order";
      if (/order[_-]?plain/i.test(text)) return "order";
      try { const url = new URL(text); if (/order[_-]?plain/i.test(url.pathname + url.search)) return "order"; } catch {}
      return "other";
    };

    /* === å„ç¨®ãƒ‘ãƒ¼ã‚µ === */
    const tryExtractWN = (rawUrl) => {
      try {
        const u = new URL(rawUrl);
        const m = /[#&]d=([^&]+)/.exec(u.hash || "");
        if (!m) return "";
        const b64 = m[1].replace(/-/g, '+').replace(/_/g, '/');
        const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
        const json = atob(b64 + pad);
        const obj = JSON.parse(json);
        return (obj.wn || "").trim();
      } catch { return ""; }
    };

    const parseDie = (raw) => {
      const text = normalizeHyphen((raw || "").trim());
      let match = /^die-([^-\n]+)-([^-]+)(?:-(.+))?$/i.exec(text);
      if (match) return { bn: match[1].trim(), wc: match[2].trim(), wn: (match[3] || "").trim() };
      try {
        const url = new URL(text);
        const book = url.searchParams.get("book") || "";
        const wc = url.searchParams.get("wc") || "";
        if (book || wc) {
          const wnFromParam = (url.searchParams.get("wn") || "").trim();
          const wnFromHash = tryExtractWN(text);
          return { bn: book.trim(), wc: wc.trim(), wn: wnFromParam || wnFromHash };
        }
      } catch {}
      return null;
    };

    const parseLoc = (raw) => {
      const text = normalizeHyphen((raw || "").trim());
      let match = /^loc-(.+)$/i.exec(text);
      if (match) return { loc: match[1].trim() };
      try { const url = new URL(text); const loc = url.searchParams.get("loc") || ""; if (loc) return { loc: loc.trim() }; } catch {}
      return null;
    };

    const parseOrderPlain = (raw) => {
      const text = normalizeHyphen((raw || "").trim());
      let m = /^order-([^-\n]+)-([^-]+)(?:-(.+))?$/i.exec(text);
      if (m) return { bn: m[1].trim(), wc: m[2].trim() };
      try {
        const url = new URL(text);
        if (/order[_-]?plain/i.test(url.pathname + url.search)) {
          const book = (url.searchParams.get("book") || url.searchParams.get("Book") || "").trim();
          const wc   = (url.searchParams.get("wc")   || url.searchParams.get("WorkCord") || "").trim();
          if (book || wc) return { bn: book, wc };
        }
      } catch {}
      m = /order(?:[_-]?plain)?[:\s-]+([^\s/:-]+)[\s/:-]+([^\s/:-]+)/i.exec(text);
      if (m) return { bn: m[1].trim(), wc: m[2].trim() };
      return null;
    };

    const dieKey = (bn, wc) => `${(bn || "").trim().toLowerCase()}@@${(wc || "").trim().toLowerCase()}`;

    /* === æç”»ãƒ»UI === */
    function drawBox(points, color, label, style = 'solid') {
      if (!points || points.length < 4) return;
      overlayCtx.save();
      const isNG = (color === CONFIG.colors.ng);
      overlayCtx.lineWidth = isNG ? 4 : (color === CONFIG.colors.ok ? 5 : 3);
      overlayCtx.setLineDash(style === 'dashed' ? [8, 6] : []);
      overlayCtx.shadowColor = color;
      overlayCtx.shadowBlur = 4;
      overlayCtx.strokeStyle = color;
      overlayCtx.beginPath();
      overlayCtx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) overlayCtx.lineTo(points[i].x, points[i].y);
      overlayCtx.closePath();
      overlayCtx.stroke();
      overlayCtx.restore();
    }

    function showToastNearBox(text, points) {
      if(!points || points.length < 2) return;
      const el = document.createElement("div");
      el.className = "toast";
      el.textContent = text;
      const x = (points[0].x + points[1].x) / 2;
      const y = Math.min(points[0].y, points[1].y);
      const rx = x / DOM.overlay.width * DOM.video.clientWidth;
      const ry = y / DOM.overlay.height * DOM.video.clientHeight;
      el.style.left = rx + "px";
      el.style.top = ry + "px";
      DOM.stack.appendChild(el);
      setTimeout(() => el.remove(), 1200);
    }

    function showBigMessage(text, sub = "") {
      document.querySelectorAll(".bigmsg").forEach(el => el.remove());
      const el = document.createElement("div");
      el.className = "bigmsg";
      el.textContent = text;
      if (sub) {
        const s = document.createElement("span");
        s.className = "sub";
        s.textContent = sub;
        el.appendChild(s);
      }
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1500);
    }

    function fitOverlay() {
      if (DOM.video.videoWidth === 0) return;
      DOM.overlay.width = DOM.video.videoWidth;
      DOM.overlay.height = DOM.video.videoHeight;
      DOM.overlay.style.width = DOM.video.clientWidth + "px";
      DOM.overlay.style.height = DOM.video.clientHeight + "px";
    }

    function stopCam() {
      if (state.rafId) cancelAnimationFrame(state.rafId);
      state.rafId = null;
      if (state.stream) state.stream.getTracks().forEach(t => t.stop());
      state.stream = null;
      DOM.btnStart.disabled = false;
      DOM.btnStop.disabled = true;
      updateStatus("åœæ­¢ä¸­");
    }

    function showError(e) {
      console.error(e);
      DOM.error.textContent = `âŒ ${e?.name || ""} ${e?.message || e}`;
    }

    async function startCam() {
      stopCam();
      DOM.error.textContent = "";
      try {
        state.stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        DOM.video.srcObject = state.stream;
        await DOM.video.play();
        DOM.btnStart.disabled = true;
        DOM.btnStop.disabled = false;
        if (state.useBarcodeDetector) {
          try { state.detector = new BarcodeDetector({ formats: ["qr_code"] }); }
          catch { state.useBarcodeDetector = false; state.detector = null; }
        }
        DOM.detectorInfo.textContent = state.useBarcodeDetector ? "BarcodeDetector" : "jsQR";
        fitOverlay();
        tick();
      } catch (e) { showError(e); updateStatus("ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼", "ng"); }
    }

    /* === æ¤œå‡º === */
    async function detectCombined() {
      if (!DOM.video.videoWidth) return [];
      const tmpCanvas = document.createElement("canvas");
      tmpCanvas.width = DOM.video.videoWidth;
      tmpCanvas.height = DOM.video.videoHeight;
      const tctx = tmpCanvas.getContext("2d", { willReadFrequently: true });
      tctx.drawImage(DOM.video, 0, 0, tmpCanvas.width, tmpCanvas.height);

      const allDetections = new Map();

      if (state.useBarcodeDetector && state.detector) {
        try {
          const codes = await state.detector.detect(tmpCanvas);
          codes.forEach(code => allDetections.set(code.rawValue, code));
        } catch (e) { console.warn("BarcodeDetector failed.", e); }
      }

      const imgData = tctx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height);
      const maskedData = new Uint8ClampedArray(imgData.data);

      for (let k = 0; k < 10; k++) {
        const hit = jsQR(maskedData, imgData.width, imgData.height, { inversionAttempts: 'dontInvert' });
        if (!hit) break;

        const raw = hit.data;
        if (!allDetections.has(raw)) {
          allDetections.set(raw, {
            rawValue: raw,
            cornerPoints: [
              hit.location.topLeftCorner,
              hit.location.topRightCorner,
              hit.location.bottomRightCorner,
              hit.location.bottomLeftCorner
            ]
          });
        }
        const { topLeftCorner, bottomRightCorner } = hit.location;
        for (let y = Math.floor(topLeftCorner.y); y < Math.ceil(bottomRightCorner.y); y++) {
          for (let x = Math.floor(topLeftCorner.x); x < Math.ceil(bottomRightCorner.x); x++) {
            const i = (y * imgData.width + x) * 4;
            maskedData[i] = maskedData[i + 1] = maskedData[i + 2] = 255;
          }
        }
      }
      return Array.from(allDetections.values());
    }

    function holdScan(ms) {
      if (state.holdTimer) clearTimeout(state.holdTimer);
      if (state.rafId) cancelAnimationFrame(state.rafId);
      state.rafId = null;
      updateStatus("ãƒ­ãƒƒã‚¯ä¸­", "ok");
      state.holdTimer = setTimeout(() => {
        if (!state.rafId) tick();
        state.holdTimer = null;
      }, ms);
    }

    function updateHistory(raw, kind, isMatch) {
      if (state.scanHistory.has(raw)) return;
      state.scanHistory.set(raw, { kind, isMatch, time: new Date() });
    }

    /* === æ¤œå‡ºçµæœé©ç”¨ === */
    function applyDetections(detections) {
      let anyMatch = false;
      let anyLocMatch = false;
      overlayCtx.clearRect(0, 0, DOM.overlay.width, DOM.overlay.height);

      for (const d of (detections || [])) {
        const raw = (d.rawValue || "").trim();
        if (!raw) continue;

        const kind = classify(raw);
        const pts = d.cornerPoints;

        if (kind === 'die') {
          const p = parseDie(raw);
          const key = p ? dieKey(p.bn, p.wc) : "";
          const isMatch = key && key === state.targetKey;
          anyMatch = anyMatch || isMatch;

          if (isMatch) {
            drawBox(pts, CONFIG.colors.ok, "ä¸€è‡´", 'solid');
          } else {
            drawBox(pts, CONFIG.colors.ng, (p ? `ä¸ä¸€è‡´ [${p.bn}/${p.wc}]` : "ä¸ä¸€è‡´"), 'dashed');
          }

          updateHistory(raw, 'die', isMatch);

          if (isMatch && !state.isLocked) {
            state.isLocked = true;
            confirmationBeep();
            if (navigator.vibrate) { navigator.vibrate(150); }
            showBigMessage("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚", "ä¸€è‡´ã—ãŸQRã‚’é’æ ã§å¼·èª¿è¡¨ç¤ºã—ã¦ã„ã¾ã™");
            showToastNearBox("ãƒ­ãƒƒã‚¯", pts);
            speakFoundOnce(state.currentTarget.wn || (p && p.wn) || "");
            holdScan(CONFIG.holdDuration);
            setTimeout(() => { state.isLocked = false; }, CONFIG.lockCooldown);
          }

        } else if (kind === 'loc') {
          const locData = parseLoc(raw);
          const isLocMatch = state.currentShelf && locData && locData.loc.toLowerCase() === state.currentShelf.toLowerCase();
          anyLocMatch = anyLocMatch || isLocMatch;

          if (isLocMatch) {
            drawBox(pts, CONFIG.colors.loc, `æ£š ä¸€è‡´ [${locData.loc}]`, 'solid');
            updateHistory(raw, 'loc', true);
            if (!state.isLocked) showToastNearBox("ç›®çš„ã®æ£šã§ã™", pts);
            speakTargetLocFound();
          } else {
            const label = `æ£š é•ã„ [${locData?.loc || '?'}]`;
            drawBox(pts, CONFIG.colors.ng, label, 'dashed');
            updateHistory(raw, 'loc', false);
            if (!state.isLocked && state.currentShelf) {
              showToastNearBox(`æ£šãŒé•ã„ã¾ã™ (â†’ ${state.currentShelf})`, pts);
            }
          }

        } else if (kind === 'order') {
          const od = parseOrderPlain(raw);
          if (od && (od.bn || od.wc)) {
            const newKey = dieKey(od.bn, od.wc);
            const now = performance.now();
            const sameAsBefore = (newKey === state.__lastOrderKey);
            const stillCooling = (now - state.__orderSetAt) < CONFIG.orderResetCooldownMs;

            drawBox(pts, CONFIG.colors.info, `ä½œæ¥­æŒ‡ç¤º [${od.bn||'-'}/${od.wc||'-'}]`, 'solid');
            updateHistory(raw, 'order', true);

            if (!sameAsBefore || !stillCooling || newKey !== state.targetKey) {
              setTarget(od.bn || "", od.wc || "", "");
              state.__lastOrderKey = newKey;
              state.__orderSetAt = now;
              const b = state.currentTarget.book || "-";
const w = state.currentTarget.wc || "-";

showBigMessage("ä½œæ¥­æŒ‡ç¤ºQRã‚’èª­ã¿å–ã‚Šã¾ã—ãŸ", `ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: Book=${b} / WC=${w}`);
showToastNearBox(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ›´æ–° (${b}/${w})`, pts);

// èª­ã¿ä¸Šã’ï¼ˆbook / wc ã‚’å«ã‚ã‚‹ï¼‰
speakLineOnce(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ book ${b} ã€wc ${w} ã«è¨­å®šã—ã¾ã—ãŸã€‚ãŠæ¢ã—ã®å‹ã‚’æ£šã‹ã‚‰ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ãã ã•ã„ã€‚`, { cooldown: 2500 });

              holdScan(800);
            }
          } else {
            drawBox(pts, CONFIG.colors.ng, "ä½œæ¥­æŒ‡ç¤ºï¼ˆå½¢å¼ä¸æ˜ï¼‰", 'dashed');
            updateHistory(raw, 'order', false);
          }

        } else {
          drawBox(pts, CONFIG.colors.ng, "åˆ¥QR", 'dashed');
          updateHistory(raw, 'other', false);
        }
      }

      if (!state.holdTimer) {
        let msg = "æ¢ç´¢ä¸­...";
        let statusType = "info";
        if (detections.length > 0) {
          if (anyMatch) { msg = "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç™ºè¦‹"; statusType = "ok"; }
          else if (anyLocMatch) { msg = "ç›®çš„ã®æ£šã‚’æ¤œçŸ¥"; statusType = "loc"; }
          else { msg = `${detections.length}ä»¶æ¤œçŸ¥`; statusType = "ng"; }
        }
        updateStatus(msg, statusType);
      }
    }

    async function tick() {
      if (!state.stream) return;
      if (DOM.video.readyState === DOM.video.HAVE_ENOUGH_DATA) {
        fitOverlay();
        const detections = await detectCombined();
        applyDetections(detections);
      }
      state.rafId = requestAnimationFrame(tick);
    }

    function updateStatus(text, type = 'info') {
      DOM.scanStatus.textContent = text;
      DOM.scanStatus.className = `badge chip ${type}`;
    }

    function showHistoryModal() {
      DOM.historyList.innerHTML = '';
      if(state.scanHistory.size === 0){
        DOM.historyList.innerHTML = '<li>ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>';
      } else {
        const sortedHistory = Array.from(state.scanHistory.entries()).reverse();
        for (const [raw, data] of sortedHistory) {
          const li = document.createElement('li');
          let status = '';
          if (data.kind === 'die') status = data.isMatch ? 'âœ”ï¸ ä¸€è‡´ (å‹)' : 'âŒ ä¸ä¸€è‡´ (å‹)';
          else if (data.kind === 'loc') status = data.isMatch ? 'âœ”ï¸ ä¸€è‡´ (æ£š)' : 'âŒ ä¸ä¸€è‡´ (æ£š)';
          else if (data.kind === 'order') status = data.isMatch ? 'ğŸ§¾ ä½œæ¥­æŒ‡ç¤º èª­ã¿å–ã‚Š' : 'ğŸ§¾ ä½œæ¥­æŒ‡ç¤º å½¢å¼ä¸æ˜';
          else status = 'â“ ãã®ä»–';
          li.innerHTML = `<strong>${status}:</strong> ${raw.substring(0, 60)}${raw.length > 60 ? '...' : ''}`;
          DOM.historyList.appendChild(li);
        }
      }
      DOM.historyModal.style.display = 'block';
    }

    /* ====== ç›´æ¥å…¥åŠ›ï¼šã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®šé–¢æ•° ====== */
    function setTarget(book, wc, wn="") {
      state.currentTarget = { book: String(book||"").trim(), wc: String(wc||"").trim(), wn: String(wn||"").trim() };
      state.targetKey = dieKey(state.currentTarget.book, state.currentTarget.wc);
      DOM.tgtBN.textContent = state.currentTarget.book || '-';
      DOM.tgtWC.textContent = state.currentTarget.wc || '-';
      DOM.tgtWN.textContent = state.currentTarget.wn || '';
      updateStatus(state.targetKey ? "æº–å‚™å®Œäº†" : "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæœªæŒ‡å®š", state.targetKey ? "ok" : "ng");

      // URLã«locãŒç„¡ã„ â†’ è‡ªå‹•å–å¾—ã‚’è©¦ã¿ã‚‹ï¼ˆæ˜ç¤ºçš„ã«â€œå–å¾—ä¸­â€ã‚’å…ˆã«å‡ºã™ï¼‰
      const params = new URLSearchParams(location.search);
      const hasLocInUrl = (params.get("loc") || "").trim().length > 0;

      if (!hasLocInUrl) {
        state.currentShelf = null;
        DOM.currentShelf.textContent = 'ï¼ˆSheetsã‹ã‚‰å–å¾—ä¸­â€¦ï¼‰';
        DOM.currentShelf.className = 'muted';
        maybeUpdateShelfFromSheets(state.currentTarget.book, state.currentTarget.wc);

        // 5ç§’å¾…ã£ã¦ã‚‚æ±ºã¾ã‚‰ãªã„ã¨ãã®è¦‹ãˆã‚‹åŒ–
        setTimeout(() => {
          if (!state.currentShelf && /å–å¾—ä¸­/.test(DOM.currentShelf.textContent||'')) {
            DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ‰‹å‹•å…¥åŠ›ã‚’ã”åˆ©ç”¨ãã ã•ã„ï¼‰';
            DOM.currentShelf.className = 'muted';
          }
        }, 5000);
      }
    }


    /* ====== å…¥åŠ›UIã®ã‚¤ãƒ™ãƒ³ãƒˆ ====== */
    DOM.btnApply.addEventListener('click', () => {
      const b = (DOM.inBook.value||'').trim();
      const w = (DOM.inWc.value||'').trim();
      if (!b || !w) { alert('Book ã¨ WC ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
      setTarget(b, w, "");
      speakLineOnce("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®šã—ã¾ã—ãŸã€‚ãŠæ¢ã—ã®å‹ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ãã ã•ã„ã€‚");
    });
    DOM.btnFill.addEventListener('click', () => {
      DOM.inBook.value = state.currentTarget.book || '';
      DOM.inWc.value   = state.currentTarget.wc || '';
    });
    DOM.btnClear.addEventListener('click', () => {
      DOM.inBook.value = '';
      DOM.inWc.value = '';
    });
    // Enterç¢ºå®šï¼ˆã©ã¡ã‚‰ã‹ã§Enterâ†’è¨­å®šï¼‰
    DOM.inBook.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ DOM.btnApply.click(); }});
    DOM.inWc.addEventListener('keydown',   (e)=>{ if(e.key==='Enter'){ DOM.btnApply.click(); }});

    /* ====== ãƒ¢ãƒ¼ãƒ€ãƒ«/ãã®ä»– ====== */
    DOM.btnStart.addEventListener("click", () => { initTTS(); unlockTTS(); startCam(); });
    DOM.btnStop.addEventListener("click", stopCam);
    DOM.btnHistory.addEventListener("click", showHistoryModal);
    DOM.closeModal.addEventListener("click", () => DOM.historyModal.style.display = 'none');
    window.addEventListener("click", (event) => { if (event.target == DOM.historyModal) DOM.historyModal.style.display = "none"; });

    DOM.fileTest.addEventListener("change", async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const img = new Image();
      img.onload = async () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.width; canvas.height = img.height;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const hits = jsqrMulti(imgData).map(h => ({ rawValue: h.rawValue, cornerPoints: h.cornerPoints }));
        DOM.overlay.width = img.width; DOM.overlay.height = img.height;
        applyDetections(hits);
        updateStatus(`é™æ­¢ç”»ãƒ†ã‚¹ãƒˆ: ${hits.length}ä»¶æ¤œçŸ¥`);
        ev.target.value = "";
      };
      img.src = URL.createObjectURL(file);
    });

    function jsqrMulti(imgData) {
      const hits = [];
      const maskedData = new Uint8ClampedArray(imgData.data);
      for (let k = 0; k < 10; k++) {
        const hit = jsQR(maskedData, imgData.width, imgData.height, { inversionAttempts: 'dontInvert' });
        if (!hit) break;
        hits.push({
          rawValue: hit.data,
          cornerPoints: [
            hit.location.topLeftCorner,
            hit.location.topRightCorner,
            hit.location.bottomRightCorner,
            hit.location.bottomLeftCorner
          ]
        });
        const { topLeftCorner, bottomRightCorner } = hit.location;
        for (let y = Math.floor(topLeftCorner.y); y < Math.ceil(bottomRightCorner.y); y++) {
          for (let x = Math.floor(topLeftCorner.x); x < Math.ceil(bottomRightCorner.x); x++) {
            const i = (y * imgData.width + x) * 4;
            maskedData[i] = maskedData[i + 1] = maskedData[i + 2] = 255;
          }
        }
      }
      return hits;
    }

    /* ====== åˆæœŸåŒ– ====== */
    function initialize() {
      const params = new URLSearchParams(location.search);
      const book = (params.get("book") || "").trim();
      const wc   = (params.get("wc")   || "").trim();
      const wn   = (params.get("wn")   || "").trim();

      if (!book || !wc) {
        updateStatus("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæœªæŒ‡å®šï¼ˆä½œæ¥­æŒ‡ç¤ºQRã‚’èª­ã¿å–ã‚‹ã‹ã€ç›´æ¥å…¥åŠ›/URLã§æŒ‡å®šï¼‰", "ng");
        DOM.error.textContent = "URLã« ?book=...&wc=... ã‚’æŒ‡å®šã€ã¾ãŸã¯ä½œæ¥­æŒ‡ç¤ºQRï¼ˆorder_Plainï¼‰/ç›´æ¥å…¥åŠ›ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚";
        DOM.btnStart.disabled = false;
      } else {
        setTarget(book, wc, wn);
      }

      const locParam = (params.get("loc") || "").trim();
      if (locParam) {
        state.currentShelf = locParam;
        DOM.currentShelf.textContent = state.currentShelf;
        DOM.currentShelf.className = "chip loc";
      } else {
        if (state.currentTarget.book && state.currentTarget.wc) {
          // URLã«locãŒãªãã€ã‹ã¤ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã‚ã‚Œã°Sheetsã‹ã‚‰å–å¾—
          maybeUpdateShelfFromSheets(state.currentTarget.book, state.currentTarget.wc);
        }
      }
    }

    initialize();
    // æ£šã®æ‰‹å‹•è¨­å®š
    DOM.btnLocSet.addEventListener('click', () => {
      const v = (DOM.inLoc.value || '').trim();
      if (!v) { alert('æ£šã®å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
      state.currentShelf = v;
      DOM.currentShelf.textContent = state.currentShelf;
      DOM.currentShelf.className = 'chip loc';
    });

    DOM.btnLocClear.addEventListener('click', () => {
      state.currentShelf = null;
      DOM.inLoc.value = '';
      DOM.currentShelf.textContent = 'ï¼ˆURLæœªæŒ‡å®šï¼‰';
      DOM.currentShelf.className = 'muted';
    });

  });
  </script>
</body>
</html>
