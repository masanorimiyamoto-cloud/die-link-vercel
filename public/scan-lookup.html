<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>æŠœå‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ï½œç”Ÿç”£ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  /* æ—¢å­˜ã®CSSã‚¹ã‚¿ã‚¤ãƒ«ã¯å¤‰æ›´ãªã— */
  :root {
    --ok: #1c7ed6; --ng: #e03131; --loc: #2b8a3e; --info: #f59f00;
    --tx: #212529; --sub: #6c757d; --bg: #f8f9fa; --bd: #dee2e6;
    --primary: #1c7ed6; --secondary: #6c757d; --success: #22c55e; --warning: #f59e0b;
    --bg-ok: #e7f5ff; --bg-ng: #fff5f5; --bg-loc: #e6fcf5; --bg-info: #fff9db;
  }
  
  /* ... æ—¢å­˜ã®CSSã‚¹ã‚¿ã‚¤ãƒ«ã¯ãã®ã¾ã¾ ... */
</style>
</head>
<body>
<div class="wrap">
  <!-- æ—¢å­˜ã®HTMLæ§‹é€ ã¯å¤‰æ›´ãªã— -->
</div>

<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" crossorigin="anonymous"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // ===== ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½ =====
  const tabBtns = document.querySelectorAll('.tab-btn');
  const tabContents = document.querySelectorAll('.tab-content');
  
  tabBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const tabId = this.getAttribute('data-tab');
      
      tabBtns.forEach(b => b.classList.remove('active'));
      tabContents.forEach(c => c.classList.remove('active'));
      
      this.classList.add('active');
      document.getElementById(`${tabId}-tab`).classList.add('active');
      
      if (tabId === 'scanner' && window.state && window.state.stream) {
        setTimeout(() => {
          fitOverlay();
        }, 100);
      }
    });
  });

  // ===== ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ =====
  const DOM = {
    video: document.getElementById('video'),
    overlay: document.getElementById('overlay'),
    stack: document.getElementById('stack'),
    btnStart: document.getElementById('btnStart'),
    btnStop: document.getElementById('btnStop'),
    btnFlipCamera: document.getElementById('btnFlipCamera'),
    tgtBN: document.getElementById('tgtBN'),
    tgtWC: document.getElementById('tgtWC'),
    tgtWN: document.getElementById('tgtWN'),
    currentShelf: document.getElementById('currentShelf'),
    scanStatusBadge: document.getElementById('scanStatusBadge'),
    detectorInfo: document.getElementById('detectorInfo'),
    error: document.getElementById('error'),
    fileTest: document.getElementById('fileTest'),
    historyModal: document.getElementById('historyModal'),
    historyList: document.getElementById('historyList'),
    closeModal: document.getElementById('closeModal'),
    btnShowHistory: document.getElementById('btnShowHistory'),
    inBook: document.getElementById('inBook'),
    inWc: document.getElementById('inWc'),
    btnSetTarget: document.getElementById('btnSetTarget'),
  };

  const overlayCtx = DOM.overlay.getContext('2d', { willReadFrequently: true });

  const state = {
    stream: null,
    rafId: null,
    detector: null,
    useBarcodeDetector: ('BarcodeDetector' in window),
    isLocked: false,
    holdTimer: null,
    currentTarget: {},
    targetKey: '',
    currentShelf: null,
    scanHistory: new Map(),
    __lastOrderKey: '',
    __orderSetAt: 0,
    csrf: '',
    facingMode: 'environment'
  };

  // ===== CSRFé–¢é€£é–¢æ•° =====
  const readCookie = (name) => {
    const m = document.cookie.match(new RegExp('(?:^|; )'+name.replace(/[-/\\^$*+?.()|[\\]{}]/g,'\\$&')+'=([^;]*)'));
    return m ? decodeURIComponent(m[1]) : '';
  };

  async function requestSession(){
    const url = '/api/session';
    try {
      await fetch(url, { 
        method: 'GET', 
        credentials: 'same-origin', 
        cache: 'no-store' 
      });
    } catch (error) {
      console.warn('Session request failed:', error);
    }
  }

  async function ensureCsrf(){
    let t = readCookie('xcsrf');
    if(!t){ 
      await requestSession(); 
      t = readCookie('xcsrf'); 
    }
    if(!t) throw new Error('CSRF Cookie(xcsrf)ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
    state.csrf = t;
    console.log('CSRF token acquired:', state.csrf);
  }

  // ===== Google Sheetsã‹ã‚‰Locationå–å¾— =====
  let __lastShelfFetchKey = '';
   // â˜… force è¿½åŠ ç‰ˆ
  async function maybeUpdateShelfFromSheets(book, wc, { force = false } = {}) {
    if (!book || !wc) return;
    const key = (book + '@@' + wc).toLowerCase();

    // â˜…å¼·åˆ¶ã˜ã‚ƒãªã„ã¨ãã ã‘å¤ã„ã‚­ãƒ¼ã‚’è¦‹ã¦ã‚¹ã‚­ãƒƒãƒ—
    if (!force) {
      if (__lastShelfFetchKey === key) return;
      // ã™ã§ã«æ£šãŒå…¥ã£ã¦ã‚‹ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå¼·åˆ¶ã®ã¨ãã¯é€šã™ï¼‰
      if (state.currentShelf) return;
    }

    __lastShelfFetchKey = key;
    DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±å–å¾—ä¸­â€¦ï¼‰';

    try {
      const loc = await mockFetchLocation(book, wc);
      if (loc) {
        state.currentShelf = loc;
        DOM.currentShelf.textContent = state.currentShelf;
      } else {
        state.currentShelf = null; // â˜…è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚‰æ¶ˆã—ã¦ãŠã
        DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±ãªã—ï¼‰';
      }
    } catch (e) {
      console.warn('Locationå–å¾—å¤±æ•—:', e);
      state.currentShelf = null;
      DOM.currentShelf.textContent = 'ï¼ˆå–å¾—å¤±æ•—ï¼‰';
    }
  }

  // ===== æ‰‹å‹•ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®šï¼ˆä¿®æ­£ç‰ˆï¼‰ =====
  
  function setTargetByManual(book, wc) {
    book = (book || '').trim();
    wc   = (wc   || '').trim();
    if (!book || !wc) {
      alert('book ã¨ wc ã‚’å…¥åŠ›ï¼ˆé¸æŠï¼‰ã—ã¦ãã ã•ã„');
      return;
    }

    state.currentTarget = { book, wc, wn: '' };
    state.targetKey = dieKey(book, wc);

    DOM.tgtBN.textContent = book;
    DOM.tgtWC.textContent = wc;
    DOM.tgtWN.textContent = '';

    // â˜…ã“ã“ã§ã„ã£ãŸã‚“æ£šã‚’ã‚¯ãƒªã‚¢ã—ã¦ãŠã
    state.currentShelf = null;
    DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±å–å¾—ä¸­â€¦ï¼‰';

    updateStatus('ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š', 'ok');
    showBigMessage('æ‰‹å‹•ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š', `Book=${book} / WC=${wc}`);
    speakLineOnce(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ ${book} ${wc} ã«è¨­å®š`);

    // â˜…æ‰‹å‹•å…¥åŠ›ã®ã¨ãã¯å¼·åˆ¶ã§æ£šã‚’å–ã‚Šã«è¡Œã
    maybeUpdateShelfFromSheets(book, wc, { force: true });
  }

  // ===== æ®‹ã‚Šã®é–¢æ•°ã¯å¤‰æ›´ãªã— =====
  function updateStatus(text, type = 'ready') {
    DOM.scanStatusBadge.textContent = text;
    DOM.scanStatusBadge.className = `scan-status ${type}`;
  }

  function showError(e) {
    console.error(e);
    DOM.error.textContent = `âŒ ${e?.name || ""} ${e?.message || e}`;
    DOM.error.style.display = 'block';
  }

  function clearError() {
    DOM.error.textContent = '';
    DOM.error.style.display = 'none';
  }

  // ===== éŸ³å£°é–¢é€£ =====
  let __jpVoices = [];
  let __lastSpeak = 0;
  let __lastLocSpeak = 0;
  const __speakCooldownMs = 1500;
  const __locSpeakCooldownMs = 3000;

  function initTTS() {
    if (!('speechSynthesis' in window)) return;
    const synth = window.speechSynthesis;
    function loadVoices() {
      const voices = synth.getVoices();
      __jpVoices = voices
        .filter(v => /ja|jpn|æ—¥æœ¬èª/i.test(v.lang) || /æ—¥æœ¬èª/i.test(v.name))
        .sort((a,b) => {
          const pref = ['Google æ—¥æœ¬èª', 'Kyoko', 'Otoya'];
          const ia = pref.findIndex(p => (a.name||'').includes(p));
          const ib = pref.findIndex(p => (b.name||'').includes(p));
          return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
        });
    }
    loadVoices();
    synth.onvoiceschanged = loadVoices;
  }

  const punct = s => String(s||"").replace(/\s+/g, ' ').trim();
  
  function unlockTTS() {
    if (!('speechSynthesis' in window)) return;
    const u = new SpeechSynthesisUtterance(' ');
    u.lang = 'ja-JP'; u.volume = 0; u.rate = 1; u.pitch = 1;
    try { window.speechSynthesis.speak(u); } catch {}
  }
  
  function speakAfterReady(utterance) {
    if (!('speechSynthesis' in window)) return;
    const synth = window.speechSynthesis;
    const trySpeak = (retries = 2) => {
      try { synth.cancel(); } catch {}
      const voices = synth.getVoices();
      if (voices && voices.length && __jpVoices.length === 0) {
        __jpVoices = voices.filter(v =>
          /ja|jpn|æ—¥æœ¬èª/i.test(v.lang) || /æ—¥æœ¬èª|Kyoko|Google æ—¥æœ¬èª/i.test(v.name)
        );
        if (__jpVoices.length) utterance.voice = __jpVoices[0];
      }
      try { synth.speak(utterance); }
      catch (e) { if (retries > 0) setTimeout(() => trySpeak(retries - 1), 200); }
    };
    trySpeak();
  }

  function speakFoundOnce(workName) {
    if (!('speechSynthesis' in window)) return;
    const now = performance.now();
    if (now - __lastSpeak < __speakCooldownMs) return;
    __lastSpeak = now;
    const hasWN = !!workName && String(workName).trim().length > 0;
    const text = hasWN ? `ãŠæ¢ã—ã®å‹ã€${workName}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚` : `ãŠæ¢ã—ã®å‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚`;
    const u = new SpeechSynthesisUtterance(punct(text));
    u.lang='ja-JP'; u.rate=1.0; u.pitch=1.1; u.volume=1.0;
    if (__jpVoices.length > 0) u.voice = __jpVoices[0];
    speakAfterReady(u);
  }

  function speakTargetLocFound() {
    if (!('speechSynthesis' in window)) return;
    const now = performance.now();
    if (now - __lastLocSpeak < __locSpeakCooldownMs) return;
    __lastLocSpeak = now;
    const u = new SpeechSynthesisUtterance("ç›®çš„ã®æ£šã§ã™");
    u.lang='ja-JP'; u.rate=1.0; u.pitch=1.1; u.volume=0.8;
    if (__jpVoices.length > 0) u.voice = __jpVoices[0];
    speakAfterReady(u);
  }

  let __lastGenericSpeak = 0;
  function speakLineOnce(text, {rate=1.08, pitch=1.4, cooldown=1200} = {}) {
    if (!('speechSynthesis' in window)) return;
    const now = performance.now();
    if (now - __lastGenericSpeak < cooldown) return;
    __lastGenericSpeak = now;
    const u = new SpeechSynthesisUtterance(punct(text));
    u.lang='ja-JP';u.rate=rate;u.pitch=pitch;u.volume=1.0;
    if (__jpVoices.length>0) u.voice=__jpVoices[0];
    speakAfterReady(u);
  }

  // ===== éŸ³å£°ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ =====
  const confirmationBeep = (() => {
    let audioCtx;
    const play = () => {
      try {
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const t0 = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, t0);
        osc.frequency.exponentialRampToValueAtTime(1200, t0 + 0.1);
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.0001, t0);
        gain.gain.exponentialRampToValueAtTime(0.4, t0 + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.2);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(t0);
        osc.stop(t0 + 0.25);
      } catch {}
    };
    return play;
  })();

  // ===== æ–‡å­—åˆ—æ­£è¦åŒ– =====
  const normalizeHyphen = s => (s || "").replace(/[â€-â€’â€“â€”â€•ãƒ¼âˆ’]/g, "-");

  // ===== QRã‚³ãƒ¼ãƒ‰åˆ†é¡ =====
  const classify = (raw) => {
    const text = normalizeHyphen((raw || "").trim());
    if (/^loc-/i.test(text)) return "loc";
    try { const url = new URL(text); if (url.searchParams.has("loc")) return "loc"; } catch {}
    if (/^die-/i.test(text)) return "die";
    try { const url = new URL(text); if (url.searchParams.has("book") || url.searchParams.has("wc")) return "die"; } catch {}
    if (/^order-/i.test(text)) return "order";
    if (/order[_-]?plain/i.test(text)) return "order";
    try { const url = new URL(text); if (/order[_-]?plain/i.test(url.pathname + url.search)) return "order"; } catch {}
    return "other";
  };

  // ===== ãƒ‘ãƒ¼ã‚µãƒ¼é–¢æ•° =====
  const tryExtractWN = (rawUrl) => {
    try {
      const u = new URL(rawUrl);
      const m = /[#&]d=([^&]+)/.exec(u.hash || "");
      if (!m) return "";
      const b64 = m[1].replace(/-/g, '+').replace(/_/g, '/');
      const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
      const json = atob(b64 + pad);
      const obj = JSON.parse(json);
      return (obj.wn || "").trim();
    } catch { return ""; }
  };

  const parseDie = (raw) => {
    const text = normalizeHyphen((raw || "").trim());
    let match = /^die-([^-\n]+)-([^-]+)(?:-(.+))?$/i.exec(text);
    if (match) return { bn: match[1].trim(), wc: match[2].trim(), wn: (match[3] || "").trim() };
    try {
      const url = new URL(text);
      const book = url.searchParams.get("book") || "";
      const wc = url.searchParams.get("wc") || "";
      if (book || wc) {
        const wnFromParam = (url.searchParams.get("wn") || "").trim();
        const wnFromHash = tryExtractWN(text);
        return { bn: book.trim(), wc: wc.trim(), wn: wnFromParam || wnFromHash };
      }
    } catch {}
    return null;
  };

  const parseLoc = (raw) => {
    const text = normalizeHyphen((raw || "").trim());
    let match = /^loc-(.+)$/i.exec(text);
    if (match) return { loc: match[1].trim() };
    try {
      const url = new URL(text);
      const loc = url.searchParams.get("loc") || "";
      if (loc) return { loc: loc.trim() };
    } catch {}
    return null;
  };

  const parseOrderPlain = (raw) => {
    const text = normalizeHyphen((raw || "").trim());
    let m = /^order-([^-\n]+)-([^-]+)(?:-(.+))?$/i.exec(text);
    if (m) return { bn: m[1].trim(), wc: m[2].trim() };
    try {
      const url = new URL(text);
      if (/order[_-]?plain/i.test(url.pathname + url.search)) {
        const book = (url.searchParams.get("book") || url.searchParams.get("Book") || "").trim();
        const wc   = (url.searchParams.get("wc")   || url.searchParams.get("WorkCord") || "").trim();
        if (book || wc) return { bn: book, wc };
      }
    } catch {}
    m = /order(?:[_-]?plain)?[:\s-]+([^\s/:-]+)[\s/:-]+([^\s/:-]+)/i.exec(text);
    if (m) return { bn: m[1].trim(), wc: m[2].trim() };
    return null;
  };

  const dieKey = (bn, wc) => `${(bn || "").trim().toLowerCase()}@@${(wc || "").trim().toLowerCase()}`;

  // ===== æç”»é–¢æ•° =====
  function drawBox(points, color, style = 'solid') {
    if (!points || points.length < 4) return;
    overlayCtx.save();
    overlayCtx.lineWidth = 4;
    overlayCtx.setLineDash(style === 'dashed' ? [8, 6] : []);
    overlayCtx.shadowColor = color;
    overlayCtx.shadowBlur = 8;
    overlayCtx.strokeStyle = color;
    overlayCtx.beginPath();
    overlayCtx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
      overlayCtx.lineTo(points[i].x, points[i].y);
    }
    overlayCtx.closePath();
    overlayCtx.stroke();
    overlayCtx.restore();
  }

  function showToastNearBox(text, points) {
    if(!points || points.length < 2) return;
    const el = document.createElement("div");
    el.className = "toast";
    el.textContent = text;
    const x = (points[0].x + points[1].x) / 2;
    const y = Math.min(points[0].y, points[1].y);
    const rx = x / DOM.overlay.width * DOM.video.clientWidth;
    const ry = y / DOM.overlay.height * DOM.video.clientHeight;
    el.style.left = rx + "px";
    el.style.top = ry + "px";
    DOM.stack.appendChild(el);
    setTimeout(() => el.remove(), 1200);
  }

  function showBigMessage(text, sub = "") {
    document.querySelectorAll(".bigmsg").forEach(el => el.remove());
    const el = document.createElement("div");
    el.className = "bigmsg";
    el.textContent = text;
    if (sub) {
      const s = document.createElement("span");
      s.className = "sub";
      s.textContent = sub;
      el.appendChild(s);
    }
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1500);
  }

  function fitOverlay() {
    if (!DOM.video.videoWidth || DOM.video.videoWidth === 0) return;
    DOM.overlay.width = DOM.video.videoWidth;
    DOM.overlay.height = DOM.video.videoHeight;
    DOM.overlay.style.width = DOM.video.clientWidth + "px";
    DOM.overlay.style.height = DOM.video.clientHeight + "px";
  }

  // ===== ã‚«ãƒ¡ãƒ©åˆ¶å¾¡ =====
  function stopCam() {
    if (state.rafId) cancelAnimationFrame(state.rafId);
    state.rafId = null;
    if (state.stream) {
      state.stream.getTracks().forEach(t => t.stop());
    }
    state.stream = null;
    DOM.btnStart.disabled = false;
    DOM.btnStop.disabled = true;
    DOM.btnFlipCamera.disabled = true;
    updateStatus("åœæ­¢ä¸­", "ready");
  }

  async function startCam() {
    stopCam();
    clearError();
    try {
      state.stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: state.facingMode },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });
      DOM.video.srcObject = state.stream;
      
      await new Promise((resolve) => {
        DOM.video.onloadedmetadata = () => {
          resolve();
        };
      });
      
      await DOM.video.play();
      DOM.btnStart.disabled = true;
      DOM.btnStop.disabled = false;
      DOM.btnFlipCamera.disabled = false;

      if (state.useBarcodeDetector) {
        try { 
          state.detector = new BarcodeDetector({ formats: ["qr_code"] }); 
        } catch { 
          state.useBarcodeDetector = false; 
          state.detector = null; 
        }
      }
      DOM.detectorInfo.textContent = state.useBarcodeDetector ? "BarcodeDetector" : "jsQR";
      fitOverlay();
      tick();
      updateStatus("æ¢ç´¢ä¸­â€¦", "scanning");
    } catch (e) {
      showError(e);
      updateStatus("ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼", "error");
    }
  }

  // ã‚«ãƒ¡ãƒ©åˆ‡æ›¿æ©Ÿèƒ½
  DOM.btnFlipCamera.addEventListener('click', async () => {
    state.facingMode = state.facingMode === 'environment' ? 'user' : 'environment';
    await startCam();
  });

  function holdScan(ms) {
    if (state.holdTimer) clearTimeout(state.holdTimer);
    if (state.rafId) cancelAnimationFrame(state.rafId);
    state.rafId = null;
    updateStatus("ãƒ­ãƒƒã‚¯ä¸­", "ok");
    state.holdTimer = setTimeout(() => {
      if (!state.rafId) tick();
      state.holdTimer = null;
    }, ms);
  }

  // ===== QRæ¤œå‡º =====
  async function detectCombined() {
    if (!DOM.video.videoWidth || DOM.video.videoWidth === 0) return [];
    
    const scale = 0.5;
    const srcW = DOM.video.videoWidth, srcH = DOM.video.videoHeight;
    const w = Math.floor(srcW * scale), h = Math.floor(srcH * scale);

    const tmpCanvas = document.createElement("canvas");
    tmpCanvas.width = w;
    tmpCanvas.height = h;
    const tctx = tmpCanvas.getContext("2d", { willReadFrequently: true });
    tctx.imageSmoothingEnabled = false;
    tctx.drawImage(DOM.video, 0, 0, w, h);

    const allDetections = new Map();

    if (state.useBarcodeDetector && state.detector) {
      try {
        const codes = await state.detector.detect(tmpCanvas);
        for (const code of codes) {
          const raw = (code.rawValue || "").trim();
          if (raw && !allDetections.has(raw)) {
            const scaledPoints = code.cornerPoints.map(p => ({
              x: p.x / scale,
              y: p.y / scale
            }));
            allDetections.set(raw, {
              rawValue: raw,
              cornerPoints: scaledPoints
            });
          }
        }
      } catch (e) { 
        console.warn("BarcodeDetector failed:", e);
        state.useBarcodeDetector = false;
      }
    }

    const imgData = tctx.getImageData(0, 0, w, h);
    const maskedData = new Uint8ClampedArray(imgData.data);

    for (let k = 0; k < 5; k++) {
      const hit = jsQR(maskedData, w, h, { inversionAttempts: 'dontInvert' });
      if (!hit) break;

      const raw = (hit.data || "").trim();
      if (raw && !allDetections.has(raw)) {
        const scaledPoints = [
          hit.location.topLeftCorner,
          hit.location.topRightCorner,
          hit.location.bottomRightCorner,
          hit.location.bottomLeftCorner
        ].map(p => ({
          x: p.x / scale,
          y: p.y / scale
        }));
        
        allDetections.set(raw, {
          rawValue: raw,
          cornerPoints: scaledPoints
        });
      }

      const { topLeftCorner, bottomRightCorner } = hit.location;
      const minX = Math.max(0, Math.floor(topLeftCorner.x));
      const maxX = Math.min(w, Math.ceil(bottomRightCorner.x));
      const minY = Math.max(0, Math.floor(topLeftCorner.y));
      const maxY = Math.min(h, Math.ceil(bottomRightCorner.y));
      
      for (let y = minY; y < maxY; y++) {
        for (let x = minX; x < maxX; x++) {
          const i = (y * w + x) * 4;
          maskedData[i] = maskedData[i + 1] = maskedData[i + 2] = 255;
        }
      }
    }

    return Array.from(allDetections.values());
  }

  function updateHistory(raw, kind, isMatch) {
    if (state.scanHistory.has(raw)) return;
    if (state.scanHistory.size >= 50) {
      const firstKey = state.scanHistory.keys().next().value;
      state.scanHistory.delete(firstKey);
    }
    state.scanHistory.set(raw, { kind, isMatch, time: new Date() });
  }

  // ===== æ¤œå‡ºçµæœå‡¦ç† =====
  function applyDetections(detections) {
    let anyMatch = false;
    let anyLocMatch = false;
    
    overlayCtx.clearRect(0, 0, DOM.overlay.width, DOM.overlay.height);

    for (const d of detections) {
      const raw = (d.rawValue || "").trim();
      if (!raw) continue;

      const kind = classify(raw);
      const pts = d.cornerPoints;

      if (kind === 'die') {
        const p = parseDie(raw);
        const key = p ? dieKey(p.bn, p.wc) : "";
        const isMatch = key && key === state.targetKey;
        anyMatch = anyMatch || isMatch;

        if (isMatch) {
          drawBox(pts, CONFIG.colors.ok, 'solid');
          showToastNearBox("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸€è‡´ï¼", pts);
        } else {
          drawBox(pts, CONFIG.colors.ng, 'dashed');
          const label = p ? `ä¸ä¸€è‡´ [${p.bn}/${p.wc}]` : "ä¸æ˜ãªå½¢å¼";
          showToastNearBox(label, pts);
        }

        updateHistory(raw, 'die', isMatch);

        if (isMatch && !state.isLocked) {
          state.isLocked = true;
          confirmationBeep();
          if (navigator.vibrate) navigator.vibrate(150);
          showBigMessage("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ", "ä¸€è‡´ã—ãŸQRã‚’é’æ ã§å¼·èª¿è¡¨ç¤º");
          speakFoundOnce(state.currentTarget.wn || (p && p.wn) || "");
          holdScan(CONFIG.holdDuration);
          setTimeout(() => { state.isLocked = false; }, CONFIG.lockCooldown);
        }

      } else if (kind === 'loc') {
        const locData = parseLoc(raw);
        const isLocMatch = state.currentShelf && locData && 
                          locData.loc.toLowerCase() === state.currentShelf.toLowerCase();
        anyLocMatch = anyLocMatch || isLocMatch;

        if (isLocMatch) {
          drawBox(pts, CONFIG.colors.loc, 'solid');
          showToastNearBox("ç›®çš„ã®æ£šã§ã™", pts);
          speakTargetLocFound();
        } else {
          drawBox(pts, CONFIG.colors.ng, 'dashed');
          const label = locData ? `æ£šé•ã„ [${locData.loc}]` : "ä¸æ˜ãªæ£šQR";
          showToastNearBox(label, pts);
        }

        updateHistory(raw, 'loc', isLocMatch);

      } else if (kind === 'order') {
        const od = parseOrderPlain(raw);
        if (od && (od.bn || od.wc)) {
          const newKey = dieKey(od.bn, od.wc);
          const now = performance.now();
          const sameAsBefore = (newKey === state.__lastOrderKey);
          const stillCooling = (now - state.__orderSetAt) < CONFIG.orderResetCooldownMs;

          drawBox(pts, CONFIG.colors.info, 'solid');
          showToastNearBox("ä½œæ¥­æŒ‡ç¤ºQR", pts);

          if (!sameAsBefore || !stillCooling || newKey !== state.targetKey) {
            state.currentTarget = { book: od.bn || "", wc: od.wc || "", wn: "" };
            state.targetKey = newKey;
            state.__lastOrderKey = newKey;
            state.__orderSetAt = now;

            DOM.tgtBN.textContent = state.currentTarget.book || "-";
            DOM.tgtWC.textContent = state.currentTarget.wc || "-";
            DOM.tgtWN.textContent = "";

            showBigMessage("ä½œæ¥­æŒ‡ç¤ºQRã‚’èª­ã¿å–ã‚Š", "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®šã—ã¾ã—ãŸ");
            speakLineOnce(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ ${state.currentTarget.book} ${state.currentTarget.wc} ã«è¨­å®š`, { cooldown: 2500 });

            // æ£šæƒ…å ±ã‚’è‡ªå‹•å–å¾—
            if (!state.currentShelf) {
              maybeUpdateShelfFromSheets(state.currentTarget.book, state.currentTarget.wc);
            }

            holdScan(800);
          }
        } else {
          drawBox(pts, CONFIG.colors.ng, 'dashed');
          showToastNearBox("ä¸æ˜ãªä½œæ¥­æŒ‡ç¤ºQR", pts);
        }

        updateHistory(raw, 'order', !!od);

      } else {
        drawBox(pts, CONFIG.colors.ng, 'dashed');
        showToastNearBox("å¯¾è±¡å¤–ã®QR", pts);
        updateHistory(raw, 'other', false);
      }
    }

    if (!state.holdTimer) {
      let msg = "æ¢ç´¢ä¸­...";
      let statusType = "scanning";

      if (detections.length > 0) {
        if (anyMatch) {
          msg = "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç™ºè¦‹ï¼";
          statusType = "ok";
        } else if (anyLocMatch) {
          msg = "ç›®çš„ã®æ£šã‚’ç™ºè¦‹";
          statusType = "loc";
        } else {
          msg = `${detections.length}ä»¶ã®QRã‚’æ¤œå‡º`;
          statusType = "scanning";
        }
      }
      updateStatus(msg, statusType);
    }
  }

  async function tick() {
    if (!state.stream) return;
    if (DOM.video.readyState === DOM.video.HAVE_ENOUGH_DATA) {
      fitOverlay();
      try {
        const detections = await detectCombined();
        applyDetections(detections);
      } catch (error) {
        console.error('Detection error:', error);
      }
    }
    state.rafId = requestAnimationFrame(tick);
  }

  // ===== å±¥æ­´è¡¨ç¤º =====
  function showHistoryModal() {
    DOM.historyList.innerHTML = '';
    if(state.scanHistory.size === 0){
      DOM.historyList.innerHTML = '<li style="text-align:center;padding:20px;color:var(--sub);">ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>';
    } else {
      const sortedHistory = Array.from(state.scanHistory.entries()).reverse();
      for (const [raw, data] of sortedHistory) {
        const li = document.createElement('li');
        let status = '';
        let icon = '';
        if (data.kind === 'die') {
          status = data.isMatch ? 'ä¸€è‡´ (å‹)' : 'ä¸ä¸€è‡´ (å‹)';
          icon = data.isMatch ? 'âœ…' : 'âŒ';
        } else if (data.kind === 'loc') {
          status = data.isMatch ? 'ä¸€è‡´ (æ£š)' : 'ä¸ä¸€è‡´ (æ£š)';
          icon = data.isMatch ? 'âœ…' : 'âŒ';
        } else if (data.kind === 'order') {
          status = data.isMatch ? 'ä½œæ¥­æŒ‡ç¤º èª­ã¿å–ã‚Š' : 'ä½œæ¥­æŒ‡ç¤º å½¢å¼ä¸æ˜';
          icon = data.isMatch ? 'ğŸ“' : 'â“';
        } else {
          status = 'ãã®ä»–';
          icon = 'â“';
        }
        
        const time = data.time.toLocaleTimeString();
        li.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px;">
            <div style="flex:1;">
              <div style="font-weight:600;margin-bottom:4px;">${icon} ${status}</div>
              <div style="font-size:12px;color:var(--sub);word-break:break-all;">${raw}</div>
            </div>
            <div style="font-size:12px;color:var(--sub);white-space:nowrap;">${time}</div>
          </div>
        `;
        DOM.historyList.appendChild(li);
      }
    }
    DOM.historyModal.style.display = 'block';
  }

  // ===== è¨­å®š =====
  const CONFIG = {
    colors: {
      ok: '#1c7ed6',
      ng: '#e03131',
      loc: '#2b8a3e',
      info: '#f59f00',
    },
    holdDuration: 3000,
    lockCooldown: 700,
    orderResetCooldownMs: 2000,
  };

  // ===== ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ =====
  DOM.btnStart.addEventListener("click", () => {
    initTTS();
    unlockTTS();
    startCam();
  });
  DOM.btnStop.addEventListener("click", stopCam);
  DOM.btnShowHistory.addEventListener("click", showHistoryModal);
  DOM.closeModal.addEventListener("click", () => DOM.historyModal.style.display = 'none');
  window.addEventListener("click", (event) => {
    if (event.target == DOM.historyModal) DOM.historyModal.style.display = "none";
  });
  
  DOM.fileTest.addEventListener("change", async (ev) => {
    const file = ev.target.files?.[0];
    if (!file) return;
    const img = new Image();
    img.onload = async () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width; canvas.height = img.height;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0);
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      const hit = jsQR(imgData.data, imgData.width, imgData.height, { inversionAttempts: 'dontInvert' });
      if (hit) {
        const hits = [{
          rawValue: hit.data,
          cornerPoints: [
            hit.location.topLeftCorner,
            hit.location.topRightCorner,
            hit.location.bottomRightCorner,
            hit.location.bottomLeftCorner
          ]
        }];
        DOM.overlay.width = img.width;
        DOM.overlay.height = img.height;
        applyDetections(hits);
        updateStatus(`ç”»åƒãƒ†ã‚¹ãƒˆ: QRã‚’æ¤œå‡º`, 'scanning');
      } else {
        updateStatus(`ç”»åƒãƒ†ã‚¹ãƒˆ: QRæœªæ¤œå‡º`, 'error');
      }
      ev.target.value = "";
    };
    img.src = URL.createObjectURL(file);
  });
  
  // æ‰‹å‹•ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®šã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ä¿®æ­£
  DOM.btnSetTarget.addEventListener('click', async () => {
    const book = DOM.inBook?.value || '';
    const wc   = DOM.inWc?.value   || '';
    await setTargetByManual(book, wc);
  });

  // ===== URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åˆæœŸåŒ–ã®ã¨ã“ã‚ã‚‚å°‘ã—ã ã‘ç›´ã™ã¨è¦ªåˆ‡ =====
  function initialize() {
    const params = new URLSearchParams(location.search);
    state.currentTarget = {
      book: (params.get("book") || "").trim(),
      wc: (params.get("wc") || "").trim(),
      wn: (params.get("wn") || "").trim()
    };

    if (state.currentTarget.book && state.currentTarget.wc) {
      DOM.tgtBN.textContent = state.currentTarget.book;
      DOM.tgtWC.textContent = state.currentTarget.wc;
      DOM.tgtWN.textContent = state.currentTarget.wn;
      state.targetKey = dieKey(state.currentTarget.book, state.currentTarget.wc);
      updateStatus("æº–å‚™å®Œäº†", "ready");

      const locParam = (params.get("loc") || "").trim();
      if (locParam) {
        state.currentShelf = locParam;
        DOM.currentShelf.textContent = state.currentShelf;
      } else {
        // â˜…URLã‹ã‚‰æ¥ãŸã¨ãã¯å¼·åˆ¶ã˜ã‚ƒãªãã¦OK
        maybeUpdateShelfFromSheets(state.currentTarget.book, state.currentTarget.wc);
      }
    } else {
      updateStatus("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæœªè¨­å®š", "scanning");
    }

    // ...ï¼ˆã“ã®ä¸‹ã¯ã‚ãªãŸã®å…ƒã® initialize ã®ã¾ã¾ã§OKï¼‰...
  }

  initialize();
});
</script>
</body>
</html>