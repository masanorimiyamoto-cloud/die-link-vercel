<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>æŠœå‹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ€ãƒ¼ QR_Manual</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --ok: #1c7ed6;
      --ng: #e03131;
      --loc: #2b8a3e;
      --info: #f59f00;
      --bd: #dee2e6; --tx: #212529; --sub: #6c757d;
      --bg-ok: #e7f5ff; --bg-ng: #fff5f5; --bg-loc: #e6fcf5;
    }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      margin: 0; padding: 12px;
      color: var(--tx);
      background: #f8f9fa;
    }
    h3, h4 { margin: 0 0 8px 0; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
    .panel { flex: 1 1 360px; min-width: 320px; }
    .card { background: #fff; border: 1px solid var(--bd); border-radius: 12px; padding: 12px; margin-bottom: 12px; }
    video { width: 100%; max-width: 520px; border-radius: 12px; background: #000; display: block; }
    .stack { position: relative; max-width: 520px; border: 1px solid var(--bd); border-radius: 12px; overflow: hidden; }
    canvas { position: absolute; inset: 0; pointer-events: none; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; align-items: center; }
    button { padding: 10px 16px; border-radius: 8px; border: 1px solid var(--bd); background: #fff; cursor: pointer; font-size: 14px; transition: background-color 0.2s; }
    button:disabled { cursor: not-allowed; opacity: 0.6; }
    button.primary { background: var(--ok); color: #fff; border-color: var(--ok); }
    button:hover:not(:disabled) { background-color: #f1f3f5; }
    button.primary:hover:not(:disabled) { background: #339af0; }
    .badge { display: inline-block; border-radius: 6px; padding: 4px 8px; font-size: 12px; border: 1px solid var(--bd); background: #f1f3f5; }
    .target-info b { font-size: 1.1em; }
    .chip { display: inline-block; padding: 2px 8px; border-radius: 99px; font-size: 12px; font-weight: 500; }
    .chip.ok { background: var(--bg-ok); color: var(--ok); border: 1px solid #a5d8ff; }
    .chip.ng { background: var(--bg-ng); color: var(--ng); border: 1px solid #ffc9c9; }
    .chip.loc { background: var(--bg-loc); color: var(--loc); border: 1px solid #96f2d7; }
    .muted { color: var(--sub); font-size: 14px; }
    .toast { position: absolute; padding: 8px 12px; background: #000c; color: #fff; border-radius: 8px; font-size: 14px; transform: translate(-50%, -150%); pointer-events: none; animation: fade-out 1.2s forwards; }
    @keyframes fade-out { from { opacity: 1; } to { opacity: 0; } }
    .legend { font-size: 12px; color: #555; margin-top: 8px; }

    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
    .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid var(--bd); width: 80%; max-width: 600px; border-radius: 12px; }
    .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--bd); padding-bottom: 10px; margin-bottom: 10px; }
    .close-button { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
    #historyList li { padding: 6px 0; border-bottom: 1px solid #eee; font-size: 14px; }

    .bigmsg {
      position: fixed;
      left: 50%;
      top: 18%;
      transform: translateX(-50%);
      z-index: 1200;
      background: rgba(28, 126, 214, 0.95);
      color: #fff;
      padding: 16px 22px;
      border-radius: 12px;
      font-size: clamp(18px, 3.2vw, 26px);
      box-shadow: 0 8px 24px rgba(0,0,0,.2);
      letter-spacing: .02em;
      text-align: center;
      pointer-events: none;
      animation: bigmsg-fade 1.2s ease-out forwards;
    }
    .bigmsg .sub { display:block; font-size: .8em; opacity: .9; margin-top: 2px; }
    @keyframes bigmsg-fade {
      0%   { opacity: 0; transform: translateX(-50%) translateY(-8px); }
      10%  { opacity: 1; transform: translateX(-50%) translateY(0); }
      80%  { opacity: 1; }
      100% { opacity: 0; transform: translateX(-50%) translateY(-8px); }
    }

    /* ã‚¬ã‚¤ãƒ‰ã‚¹ã‚³ãƒ¼ãƒ— */
    .target-scope {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      border: 2px solid rgba(28, 126, 214, 0.8);
      border-radius: 12px;
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
    }
    .target-scope .corner-tl,
    .target-scope .corner-tr,
    .target-scope .corner-bl,
    .target-scope .corner-br {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(28, 126, 214, 0.8);
    }
    .target-scope .corner-tl {
      top: -2px;
      left: -2px;
      border-right: none;
      border-bottom: none;
      border-radius: 4px 0 0 0;
    }
    .target-scope .corner-tr {
      top: -2px;
      right: -2px;
      border-left: none;
      border-bottom: none;
      border-radius: 0 4px 0 0;
    }
    .target-scope .corner-bl {
      bottom: -2px;
      left: -2px;
      border-right: none;
      border-top: none;
      border-radius: 0 0 0 4px;
    }
    .target-scope .corner-br {
      bottom: -2px;
      right: -2px;
      border-left: none;
      border-top: none;
      border-radius: 0 0 4px 0;
    }
    .target-scope .scan-line {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(28, 126, 214, 0.8), transparent);
      animation: scan 2s linear infinite;
    }
    @keyframes scan {
      0% { top: 0; }
      100% { top: 100%; }
    }
  </style>
</head>
<body>
  <div class="row">
    <div class="panel">
      <div class="stack" id="stack">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="controls">
        <span id="scanStatus" class="badge">å¾…æ©Ÿä¸­</span>
        <label class="badge" style="cursor:pointer">ç”»åƒãƒ†ã‚¹ãƒˆ<input id="fileTest" type="file" accept="image/*" style="display:none" /></label>
        <span id="detectorInfo" class="badge"></span>
      </div>
      <div id="error" class="muted" style="color:#b00;white-space:pre-wrap;margin-top:8px;"></div>
    </div>

    <div class="panel">
      <div class="card">
        <h4>ğŸ¯ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ</h4>
        <div class="target-info">Book: <b id="tgtBN">-</b> | WC: <b id="tgtWC">-</b><br><span id="tgtWN" class="muted"></span></div>
      </div>

      <div class="card">
        <h4>æ£š æ¢ã™ã¹ãæ£š</h4>
        <div id="currentShelf" class="muted">ï¼ˆURLæœªæŒ‡å®šï¼‰</div>
      </div>

      <div class="card">
        <h4>âš™ï¸ æ“ä½œ</h4>
        <div class="controls">
          <button id="btnStart" class="primary">ã‚«ãƒ¡ãƒ©é–‹å§‹</button>
          <button id="btnStop" disabled>åœæ­¢</button>
          <button id="btnHistory">ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´</button>
        </div>
        <div class="legend">
          <span class="chip ok">ä¸€è‡´(å‹)</span>
          <span class="chip loc">ä¸€è‡´(æ£š)</span>
          <span class="chip ng">ä¸ä¸€è‡´</span>
        </div>
      </div>

      <!-- æ‰‹å…¥åŠ›ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š -->
      <div class="card">
        <h4>ğŸ“ æ‰‹å…¥åŠ›ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š</h4>
        <div class="controls" style="gap:10px;align-items:center;flex-wrap:wrap">
          <label>Book:
            <select id="inBook" style="padding:8px 10px;border:1px solid var(--bd);border-radius:10px;font-size:14px">
              <option value="" disabled selected>é¸æŠã—ã¦ãã ã•ã„</option>
              <option value="Ko">Ko</option>
              <option value="Ta">Ta</option>
              <option value="Yo">Yo</option>
            </select>
          </label>
          <label>WC:
            <input id="inWc" type="text" placeholder="ä¾‹: 2356" style="padding:8px 10px;border:1px solid var(--bd);border-radius:10px;font-size:14px;min-width:10ch">
          </label>
          <button id="btnSetTarget" class="primary">ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š</button>
        </div>
        <div class="muted" style="font-size:13px;margin-top:6px">
          ãƒ»Book ã¯ Ko / Ta / Yo ã‹ã‚‰é¸æŠã§ãã¾ã™ã€‚<br>
          ãƒ»è¨­å®šå¾Œã¯ã€è©²å½“ã®æ£šï¼ˆLocationï¼‰ã‚‚è‡ªå‹•å–å¾—ã—ã¾ã™ã€‚
        </div>
      </div>

      <div class="card">
        <h4>ğŸ’¡ ãƒ’ãƒ³ãƒˆ</h4>
        <div class="muted" style="font-size:13px;">
          ãƒ»URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ <code>?book=...&wc=...&loc=...</code> ã§æ¢ã™æŠœå‹ã¨æ£šã‚’æŒ‡å®šã—ã¾ã™ã€‚<br>
          ãƒ»ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ä¸€è‡´ã—ãŸQRã¯<strong style="color:var(--ok)">é’æ </strong>ã¨éŸ³ã¨æŒ¯å‹•ã§ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ã€‚<br>
          ãƒ»ç›®çš„ã®æ£šã¨ä¸€è‡´ã—ãŸQRã¯<strong style="color:var(--loc)">ç·‘æ </strong>ã§ãŠçŸ¥ã‚‰ã›ã—ã¾ã™ã€‚
        </div>
      </div>
    </div>
  </div>

  <div id="historyModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h4>ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´</h4>
        <span id="closeModal" class="close-button">&times;</span>
      </div>
      <ul id="historyList"></ul>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" crossorigin="anonymous"></script>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const DOM = {
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
      stack: document.getElementById('stack'),
      btnStart: document.getElementById('btnStart'),
      btnStop: document.getElementById('btnStop'),
      btnHistory: document.getElementById('btnHistory'),
      tgtBN: document.getElementById('tgtBN'),
      tgtWC: document.getElementById('tgtWC'),
      tgtWN: document.getElementById('tgtWN'),
      currentShelf: document.getElementById('currentShelf'),
      scanStatus: document.getElementById('scanStatus'),
      detectorInfo: document.getElementById('detectorInfo'),
      error: document.getElementById('error'),
      fileTest: document.getElementById('fileTest'),
      historyModal: document.getElementById('historyModal'),
      historyList: document.getElementById('historyList'),
      closeModal: document.getElementById('closeModal'),
      inBook: document.getElementById('inBook'),
      inWc: document.getElementById('inWc'),
      btnSetTarget: document.getElementById('btnSetTarget'),
    };

    const overlayCtx = DOM.overlay.getContext('2d', { willReadFrequently: true });

    const state = {
      stream: null,
      rafId: null,
      detector: null,
      useBarcodeDetector: ('BarcodeDetector' in window),
      isLocked: false,
      holdTimer: null,
      currentTarget: {},
      targetKey: '',
      currentShelf: null,
      scanHistory: new Map(),
      __lastOrderKey: '',
      __orderSetAt: 0,
      csrf: ''
    };

    /* ====== CSRF ====== */
    const isLocal = () => location.protocol === 'http:' && /localhost|127\.0\.0\.1/.test(location.host);
    const readCookie = (name) => {
      const m = document.cookie.match(new RegExp('(?:^|; )'+name.replace(/[-/\\^$*+?.()|[\\]{}]/g,'\\$&')+'=([^;]*)'));
      return m ? decodeURIComponent(m[1]) : '';
    };
    async function ensureCsrf(){
      let t = readCookie('xcsrf');
      if (t) { state.csrf = t; return t; }
      const url = isLocal() ? '/api/session?dev=1' : '/api/session';
      await fetch(url, { method:'GET', credentials:'same-origin', cache:'no-store' }).catch(()=>{});
      t = readCookie('xcsrf');
      if (t) state.csrf = t;
      return t || '';
    }

    /* ====== TTS ====== */
    let __jpVoices = [];
    let __lastSpeak = 0;
    let __lastLocSpeak = 0;
    const __speakCooldownMs = 1500;
    const __locSpeakCooldownMs = 3000;

    function initTTS() {
      if (!('speechSynthesis' in window)) return;
      const synth = window.speechSynthesis;
      function loadVoices() {
        const voices = synth.getVoices();
        __jpVoices = voices
          .filter(v => /ja|jpn|æ—¥æœ¬èª/i.test(v.lang) || /æ—¥æœ¬èª/i.test(v.name))
          .sort((a,b) => {
            const pref = ['Google æ—¥æœ¬èª', 'Kyoko', 'Otoya'];
            const ia = pref.findIndex(p => (a.name||'').includes(p));
            const ib = pref.findIndex(p => (b.name||'').includes(p));
            return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
          });
      }
      loadVoices();
      synth.onvoiceschanged = loadVoices;
    }
    const punct = s => String(s||"").replace(/\s+/g, ' ').trim();
    function unlockTTS() {
      if (!('speechSynthesis' in window)) return;
      const u = new SpeechSynthesisUtterance(' ');
      u.lang = 'ja-JP'; u.volume = 0; u.rate = 1; u.pitch = 1;
      try { window.speechSynthesis.speak(u); } catch {}
    }
    function speakAfterReady(utterance) {
      if (!('speechSynthesis' in window)) return;
      const synth = window.speechSynthesis;
      const trySpeak = (retries = 2) => {
        try { synth.cancel(); } catch {}
        const voices = synth.getVoices();
        if (voices && voices.length && __jpVoices.length === 0) {
          __jpVoices = voices.filter(v =>
            /ja|jpn|æ—¥æœ¬èª/i.test(v.lang) || /æ—¥æœ¬èª|Kyoko|Google æ—¥æœ¬èª/i.test(v.name)
          );
          if (__jpVoices.length) utterance.voice = __jpVoices[0];
        }
        try { synth.speak(utterance); }
        catch (e) { if (retries > 0) setTimeout(() => trySpeak(retries - 1), 200); }
      };
      trySpeak();
    }
    function speakFoundOnce(workName) {
      if (!('speechSynthesis' in window)) return;
      const now = performance.now();
      if (now - __lastSpeak < __speakCooldownMs) return;
      __lastSpeak = now;
      const hasWN = !!workName && String(workName).trim().length > 0;
      const text = hasWN ? `ãŠæ¢ã—ã®å‹ã€${workName}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚` : `ãŠæ¢ã—ã®å‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚`;
      const u = new SpeechSynthesisUtterance(punct(text));
      u.lang='ja-JP'; u.rate=1.0; u.pitch=1.1; u.volume=1.0;
      if (__jpVoices.length > 0) u.voice = __jpVoices[0];
      speakAfterReady(u);
    }
    function speakTargetLocFound() {
      if (!('speechSynthesis' in window)) return;
      const now = performance.now();
      if (now - __lastLocSpeak < __locSpeakCooldownMs) return;
      __lastLocSpeak = now;
      const u = new SpeechSynthesisUtterance("ç›®çš„ã®æ£šã§ã™");
      u.lang='ja-JP'; u.rate=1.0; u.pitch=1.1; u.volume=0.8;
      if (__jpVoices.length > 0) u.voice = __jpVoices[0];
      speakAfterReady(u);
    }
    let __lastGenericSpeak = 0;
    function speakLineOnce(text, {rate=1.08, pitch=1.4, cooldown=1200} = {}) {
      if (!('speechSynthesis' in window)) return;
      const now = performance.now();
      if (now - __lastGenericSpeak < cooldown) return;
      __lastGenericSpeak = now;
      const u = new SpeechSynthesisUtterance(punct(text));
      u.lang='ja-JP';u.rate=rate;u.pitch=pitch;u.volume=1.0;
      if (__jpVoices.length>0) u.voice=__jpVoices[0];
      speakAfterReady(u);
    }

    // â˜…æ£šã‚¹ã‚­ãƒ£ãƒ³ã‚¬ã‚¤ãƒ‰ã‚’1ç®‡æ‰€ã«ã¾ã¨ã‚ã‚‹
    function promptScanShelf() {
      if (state.currentShelf) {
        speakLineOnce(`æ£š ${state.currentShelf} ã®å‹ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ãã ã•ã„ã€‚`, { cooldown: 2500 });
      } else {
        speakLineOnce(`æ£šã®QRã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ãã ã•ã„ã€‚`, { cooldown: 2500 });
      }
    }

    const cssVarOr = (name, fallback) => {
      const v = getComputedStyle(document.documentElement).getPropertyValue(name);
      const s = (v || '').trim();
      return s || fallback;
    };

    const CONFIG = {
      colors: {
        ok: cssVarOr('--ok', '#1c7ed6'),
        ng: cssVarOr('--ng', '#e03131'),
        loc: cssVarOr('--loc', '#2b8a3e'),
        info: cssVarOr('--info', '#f59f00'),
      },
      holdDuration: 3000,
      lockCooldown: 700,
      orderResetCooldownMs: 2000,
      scopeSize: 200,   // ã‚¬ã‚¤ãƒ‰ã‚¹ã‚³ãƒ¼ãƒ—ã®CSSã‚µã‚¤ã‚º (æ­£æ–¹å½¢)
      scopeAllowance: 12 // å°‘ã—ã¯ã¿å‡ºã—ã¦ã‚‚OKã«ã™ã‚‹ãƒãƒ¼ã‚¸ãƒ³(pxç›¸å½“)
    };

    const confirmationBeep = (() => {
      let audioCtx;
      const play = () => {
        try {
          audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
          const t0 = audioCtx.currentTime;
          const osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(600, t0);
          osc.frequency.exponentialRampToValueAtTime(1200, t0 + 0.1);
          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(0.0001, t0);
          gain.gain.exponentialRampToValueAtTime(0.4, t0 + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.2);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(t0);
          osc.stop(t0 + 0.25);
        } catch {}
      };
      return play;
    })();

    const normalizeHyphen = s => (s || "").replace(/[â€-â€’â€“â€”â€•ãƒ¼âˆ’]/g, "-");

    /* === ç¨®åˆ¥åˆ¤å®š === */
    const classify = (raw) => {
      const text = normalizeHyphen((raw || "").trim());
      if (/^loc-/i.test(text)) return "loc";
      try { const url = new URL(text); if (url.searchParams.has("loc")) return "loc"; } catch {}
      if (/^die-/i.test(text)) return "die";
      try { const url = new URL(text); if (url.searchParams.has("book") || url.searchParams.has("wc")) return "die"; } catch {}
      if (/^order-/i.test(text)) return "order";
      if (/order[_-]?plain/i.test(text)) return "order";
      try { const url = new URL(text); if (/order[_-]?plain/i.test(url.pathname + url.search)) return "order"; } catch {}
      return "other";
    };

    /* === å„ãƒ‘ãƒ¼ã‚µ === */
    const tryExtractWN = (rawUrl) => {
      try {
        const u = new URL(rawUrl);
        const m = /[#&]d=([^&]+)/.exec(u.hash || "");
        if (!m) return "";
        const b64 = m[1].replace(/-/g, '+').replace(/_/g, '/');
        const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
        const json = atob(b64 + pad);
        const obj = JSON.parse(json);
        return (obj.wn || "").trim();
      } catch { return ""; }
    };
    const parseDie = (raw) => {
      const text = normalizeHyphen((raw || "").trim());
      let match = /^die-([^-\n]+)-([^-]+)(?:-(.+))?$/i.exec(text);
      if (match) return { bn: match[1].trim(), wc: match[2].trim(), wn: (match[3] || "").trim() };
      try {
        const url = new URL(text);
        const book = url.searchParams.get("book") || "";
        const wc = url.searchParams.get("wc") || "";
        if (book || wc) {
          const wnFromParam = (url.searchParams.get("wn") || "").trim();
          const wnFromHash = tryExtractWN(text);
          return { bn: book.trim(), wc: wc.trim(), wn: wnFromParam || wnFromHash };
        }
      } catch {}
      return null;
    };
    const parseLoc = (raw) => {
      const text = normalizeHyphen((raw || "").trim());
      let match = /^loc-(.+)$/i.exec(text);
      if (match) return { loc: match[1].trim() };
      try {
        const url = new URL(text);
        const loc = url.searchParams.get("loc") || "";
        if (loc) return { loc: loc.trim() };
      } catch {}
      return null;
    };
    const parseOrderPlain = (raw) => {
      const text = normalizeHyphen((raw || "").trim());
      let m = /^order-([^-\n]+)-([^-]+)(?:-(.+))?$/i.exec(text);
      if (m) return { bn: m[1].trim(), wc: m[2].trim() };
      try {
        const url = new URL(text);
        if (/order[_-]?plain/i.test(url.pathname + url.search)) {
          const book = (url.searchParams.get("book") || url.searchParams.get("Book") || "").trim();
          const wc   = (url.searchParams.get("wc")   || url.searchParams.get("WorkCord") || "").trim();
          if (book || wc) return { bn: book, wc };
        }
      } catch {}
      m = /order(?:[_-]?plain)?[:\s-]+([^\s/:-]+)[\s/:-]+([^\s/:-]+)/i.exec(text);
      if (m) return { bn: m[1].trim(), wc: m[2].trim() };
      return null;
    };

    const dieKey = (bn, wc) => `${(bn || "").trim().toLowerCase()}@@${(wc || "").trim().toLowerCase()}`;

    /* === GSheetã‹ã‚‰Locationå–å¾— === */
    async function fetchShelfFromGSheet(book, wc) {
      if (!book || !wc) return;
      if (state.currentShelf && state.currentShelf !== 'ï¼ˆURLæœªæŒ‡å®šï¼‰') return;

      DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±ã‚’å–å¾—ä¸­â€¦ï¼‰';
      DOM.currentShelf.className = 'muted';

      let success = false;
      try {
        const csrf = await ensureCsrf();
        const r = await fetch('/api/die-check', {
          method: 'POST',
          credentials: 'same-origin',
          headers: {
            'Content-Type':'application/json',
            ...(csrf ? {'X-CSRF': csrf} : {})
          },
          body: JSON.stringify({ book, wc, json:true, limit:1 })
        });
        const txt = await r.text();
        let j = {};
        try { j = JSON.parse(txt); }
        catch (e) { console.warn('JSON parseå¤±æ•—(POST):', txt.slice(0,200)); throw e; }

        if (!r.ok || j.ok !== true) {
          throw new Error(j?.error || `HTTP ${r.status}`);
        }

        const gs = j.gs || j.GS || j.sheet || {};
        const loc = (gs.Location ?? gs.location ?? gs.Loc ?? gs.loc ?? '').toString().trim();
        if (loc) {
          state.currentShelf = loc;
          DOM.currentShelf.textContent = loc;
          DOM.currentShelf.className = 'chip loc';
          success = true;
          // â˜…ã“ã“ã§ã‚¬ã‚¤ãƒ‰ã®ã‚»ãƒªãƒ•
          promptScanShelf();
        } else {
          DOM.currentShelf.textContent = 'ï¼ˆGSheetã«æ£šæƒ…å ±ãªã—ï¼‰';
          DOM.currentShelf.className = 'muted';
        }
      } catch (e) {
        console.warn('POSTã§æ£šæƒ…å ±å–å¾—å¤±æ•— â†’ GETã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™', e);
      }
      if (success) return;

      try {
        const qs = new URLSearchParams({ book, wc, json:'1', limit:'1' }).toString();
        const r2 = await fetch('/api/die-check?'+qs, { credentials:'same-origin' });
        const txt2 = await r2.text();
        let j2 = {};
        try { j2 = JSON.parse(txt2); }
        catch (e) { console.warn('JSON parseå¤±æ•—(GET):', txt2.slice(0,200)); throw e; }

        if (!r2.ok || j2.ok !== true) {
          throw new Error(j2?.error || `HTTP ${r2.status}`);
        }

        const gs2 = j2.gs || j2.GS || j2.sheet || {};
        const loc2 = (gs2.Location ?? gs2.location ?? gs2.Loc ?? gs2.loc ?? '').toString().trim();
        if (loc2) {
          state.currentShelf = loc2;
          DOM.currentShelf.textContent = loc2;
          DOM.currentShelf.className = 'chip loc';
          // â˜…ã“ã“ã§ã‚‚
          promptScanShelf();
        } else {
          DOM.currentShelf.textContent = 'ï¼ˆGSheetã«æ£šæƒ…å ±ãªã—ï¼‰';
          DOM.currentShelf.className = 'muted';
        }
      } catch (e) {
        console.warn('GETã§ã‚‚æ£šæƒ…å ±å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ', e);
        DOM.currentShelf.textContent = 'ï¼ˆæ£šæƒ…å ±ã®å–å¾—ã«å¤±æ•—ï¼‰';
        DOM.currentShelf.className = 'muted';
      }
    }

    /* === æç”»/UI === */
    function drawBox(points, color, label, style = 'solid', alpha=1) {
      if (!points || points.length < 4) return;
      overlayCtx.save();
      overlayCtx.globalAlpha = alpha;
      const isNG = (color === CONFIG.colors.ng);
      overlayCtx.lineWidth = isNG ? 4 : (color === CONFIG.colors.ok ? 5 : 3);
      overlayCtx.setLineDash(style === 'dashed' ? [8, 6] : []);
      overlayCtx.shadowColor = color;
      overlayCtx.shadowBlur = 4;
      overlayCtx.strokeStyle = color;
      overlayCtx.beginPath();
      overlayCtx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) overlayCtx.lineTo(points[i].x, points[i].y);
      overlayCtx.closePath();
      overlayCtx.stroke();
      overlayCtx.restore();
    }
    function showToastNearBox(text, points) {
      if(!points || points.length < 2) return;
      const el = document.createElement("div");
      el.className = "toast";
      el.textContent = text;
      const x = (points[0].x + points[1].x) / 2;
      const y = Math.min(points[0].y, points[1].y);
      const rx = x / DOM.overlay.width * DOM.video.clientWidth;
      const ry = y / DOM.overlay.height * DOM.video.clientHeight;
      el.style.left = rx + "px";
      el.style.top = ry + "px";
      DOM.stack.appendChild(el);
      setTimeout(() => el.remove(), 1200);
    }
    function showBigMessage(text, sub = "") {
      document.querySelectorAll(".bigmsg").forEach(el => el.remove());
      const el = document.createElement("div");
      el.className = "bigmsg";
      el.textContent = text;
      if (sub) {
        const s = document.createElement("span");
        s.className = "sub";
        s.textContent = sub;
        el.appendChild(s);
      }
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1500);
    }
    function fitOverlay() {
      if (DOM.video.videoWidth === 0) return;
      DOM.overlay.width = DOM.video.videoWidth;
      DOM.overlay.height = DOM.video.videoHeight;
      DOM.overlay.style.width = DOM.video.clientWidth + "px";
      DOM.overlay.style.height = DOM.video.clientHeight + "px";
    }
    function stopCam() {
      if (state.rafId) cancelAnimationFrame(state.rafId);
      state.rafId = null;
      if (state.stream) state.stream.getTracks().forEach(t => t.stop());
      state.stream = null;
      DOM.btnStart.disabled = false;
      DOM.btnStop.disabled = true;
      updateStatus("åœæ­¢ä¸­");
    }
    function showError(e) {
      console.error(e);
      DOM.error.textContent = `âŒ ${e?.name || ""} ${e?.message || e}`;
    }
    async function startCam() {
      stopCam();
      DOM.error.textContent = "";
      try {
        state.stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        DOM.video.srcObject = state.stream;
        await DOM.video.play();
        DOM.btnStart.disabled = true;
        DOM.btnStop.disabled = false;
        if (state.useBarcodeDetector) {
          try { state.detector = new BarcodeDetector({ formats: ["qr_code"] }); }
          catch { state.useBarcodeDetector = false; state.detector = null; }
        }
        DOM.detectorInfo.textContent = state.useBarcodeDetector ? "BarcodeDetector" : "jsQR";
        fitOverlay();
        addTargetScope();
        tick();
      } catch (e) { showError(e); updateStatus("ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼", "ng"); }
    }

    /* === æ¤œå‡º === */
    async function detectCombined() {
      if (!DOM.video.videoWidth) return [];
      const tmpCanvas = document.createElement("canvas");
      tmpCanvas.width = DOM.video.videoWidth;
      tmpCanvas.height = DOM.video.videoHeight;
      const tctx = tmpCanvas.getContext("2d", { willReadFrequently: true });
      tctx.drawImage(DOM.video, 0, 0, tmpCanvas.width, tmpCanvas.height);

      const allDetections = new Map();

      if (state.useBarcodeDetector && state.detector) {
        try {
          const codes = await state.detector.detect(tmpCanvas);
          codes.forEach(code => allDetections.set(code.rawValue, code));
        } catch (e) { console.warn("BarcodeDetector failed.", e); }
      }

      const imgData = tctx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height);
      const maskedData = new Uint8ClampedArray(imgData.data);

      for (let k = 0; k < 10; k++) {
        const hit = jsQR(maskedData, imgData.width, imgData.height, { inversionAttempts: 'dontInvert' });
        if (!hit) break;

        const raw = hit.data;
        if (!allDetections.has(raw)) {
          allDetections.set(raw, {
            rawValue: raw,
            cornerPoints: [
              hit.location.topLeftCorner,
              hit.location.topRightCorner,
              hit.location.bottomRightCorner,
              hit.location.bottomLeftCorner
            ]
          });
        }
        const { topLeftCorner, bottomRightCorner } = hit.location;
        for (let y = Math.floor(topLeftCorner.y); y < Math.ceil(bottomRightCorner.y); y++) {
          for (let x = Math.floor(topLeftCorner.x); x < Math.ceil(bottomRightCorner.x); x++) {
            const i = (y * imgData.width + x) * 4;
            maskedData[i] = maskedData[i + 1] = maskedData[i + 2] = 255;
          }
        }
      }
      return Array.from(allDetections.values());
    }

    // â˜…ã‚¬ã‚¤ãƒ‰ã‚¹ã‚³ãƒ¼ãƒ—å†…ã‹ã©ã†ã‹åˆ¤å®šã™ã‚‹
    function isDetectionInScope(cornerPoints) {
      if (!cornerPoints || cornerPoints.length < 4) return false;
      // DOMä¸Šã®ã‚µã‚¤ã‚º
      const stackW = DOM.stack.clientWidth;
      const stackH = DOM.stack.clientHeight;
      if (!stackW || !stackH) return true; // ä¿é™º

      // ã‚¬ã‚¤ãƒ‰ã¯ä¸­å¤®200x200ï¼ˆCSSï¼‰
      const scopeCssSize = CONFIG.scopeSize;
      const scopeCssX = (stackW / 2) - (scopeCssSize / 2);
      const scopeCssY = (stackH / 2) - (scopeCssSize / 2);

      // overlay(=video)åº§æ¨™ã¸ã‚¹ã‚±ãƒ¼ãƒ«
      const scaleX = DOM.overlay.width / stackW;
      const scaleY = DOM.overlay.height / stackH;

      const scopeX = scopeCssX * scaleX;
      const scopeY = scopeCssY * scaleY;
      const scopeW = scopeCssSize * scaleX;
      const scopeH = scopeCssSize * scaleY;

      const marginX = CONFIG.scopeAllowance * scaleX;
      const marginY = CONFIG.scopeAllowance * scaleY;

      // 4ç‚¹ã™ã¹ã¦ãŒã‚¹ã‚³ãƒ¼ãƒ—ï¼‹ãƒãƒ¼ã‚¸ãƒ³å†…ã«ã‚ã‚‹ã‹
      for (const pt of cornerPoints) {
        if (pt.x < scopeX - marginX) return false;
        if (pt.x > scopeX + scopeW + marginX) return false;
        if (pt.y < scopeY - marginY) return false;
        if (pt.y > scopeY + scopeH + marginY) return false;
      }
      return true;
    }

    function holdScan(ms) {
      if (state.holdTimer) clearTimeout(state.holdTimer);
      if (state.rafId) cancelAnimationFrame(state.rafId);
      state.rafId = null;
      updateStatus("ãƒ­ãƒƒã‚¯ä¸­", "ok");
      state.holdTimer = setTimeout(() => {
        if (!state.rafId) tick();
        state.holdTimer = null;
      }, ms);
    }

    function updateHistory(raw, kind, isMatch) {
      if (state.scanHistory.has(raw)) return;
      state.scanHistory.set(raw, { kind, isMatch, time: new Date() });
    }

    /* === æ¤œå‡ºçµæœé©ç”¨ === */
    function applyDetections(detections) {
      let anyMatch = false;
      let anyLocMatch = false;
      overlayCtx.clearRect(0, 0, DOM.overlay.width, DOM.overlay.height);

      for (const d of (detections || [])) {
        const raw = (d.rawValue || "").trim();
        if (!raw) continue;

        const pts = d.cornerPoints;

        // â˜…ã‚¬ã‚¤ãƒ‰å¤–ãªã‚‰ã€Œè¦‹ãˆã¦ã‚‹ã‘ã©ç„¡è¦–ã€
        const inScope = isDetectionInScope(pts);
        if (!inScope) {
          // è–„ãè¡¨ç¤ºã™ã‚‹ã ã‘
          drawBox(pts, CONFIG.colors.ng, "ã‚¬ã‚¤ãƒ‰å¤–", 'dashed', 0.3);
          continue;
        }

        const kind = classify(raw);

        if (kind === 'die') {
          const p = parseDie(raw);
          const key = p ? dieKey(p.bn, p.wc) : "";
          const isMatch = key && key === state.targetKey;
          anyMatch = anyMatch || isMatch;

          if (isMatch) {
            drawBox(pts, CONFIG.colors.ok, "ä¸€è‡´", 'solid');
          } else {
            drawBox(pts, CONFIG.colors.ng, (p ? `ä¸ä¸€è‡´ [${p.bn}/${p.wc}]` : "ä¸ä¸€è‡´"), 'dashed');
          }

          updateHistory(raw, 'die', isMatch);

          if (isMatch && !state.isLocked) {
            state.isLocked = true;
            confirmationBeep();
            if (navigator.vibrate) { navigator.vibrate(150); }
            showBigMessage("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚", "ä¸€è‡´ã—ãŸQRã‚’é’æ ã§å¼·èª¿è¡¨ç¤ºã—ã¦ã„ã¾ã™");
            showToastNearBox("ãƒ­ãƒƒã‚¯", pts);

            speakFoundOnce(state.currentTarget.wn || (p && p.wn) || "");

            holdScan(CONFIG.holdDuration);
            setTimeout(() => { state.isLocked = false; }, CONFIG.lockCooldown);
          }

        } else if (kind === 'loc') {
          const locData = parseLoc(raw);
          const isLocMatch = state.currentShelf && locData && locData.loc.toLowerCase() === state.currentShelf.toLowerCase();
          anyLocMatch = anyLocMatch || isLocMatch;

          if (isLocMatch) {
            drawBox(pts, CONFIG.colors.loc, `æ£š ä¸€è‡´ [${locData.loc}]`, 'solid');
            updateHistory(raw, 'loc', true);
            if (!state.isLocked) showToastNearBox("ç›®çš„ã®æ£šã§ã™", pts);
            speakTargetLocFound();
          } else {
            const label = `æ£š é•ã„ [${locData?.loc || '?'}]`;
            drawBox(pts, CONFIG.colors.ng, label, 'dashed');
            updateHistory(raw, 'loc', false);
            if (!state.isLocked && state.currentShelf) {
              showToastNearBox(`æ£šãŒé•ã„ã¾ã™ (â†’ ${state.currentShelf})`, pts);
            }
          }

        } else if (kind === 'order') {
          const od = parseOrderPlain(raw);
          if (od && (od.bn || od.wc)) {
            const newKey = dieKey(od.bn, od.wc);
            const now = performance.now();
            const sameAsBefore = (newKey === state.__lastOrderKey);
            const stillCooling = (now - state.__orderSetAt) < CONFIG.orderResetCooldownMs;

            drawBox(pts, CONFIG.colors.info, `ä½œæ¥­æŒ‡ç¤º [${od.bn||'-'}/${od.wc||'-'}]`, 'solid');
            updateHistory(raw, 'order', true);

            if (!sameAsBefore || !stillCooling || newKey !== state.targetKey) {
              state.currentTarget = { book: od.bn || "", wc: od.wc || "", wn: "" };
              state.targetKey = newKey;
              state.__lastOrderKey = newKey;
              state.__orderSetAt = now;

              DOM.tgtBN.textContent = state.currentTarget.book || "-";
              DOM.tgtWC.textContent = state.currentTarget.wc || "-";
              DOM.tgtWN.textContent = "";

              showBigMessage("ä½œæ¥­æŒ‡ç¤ºQRã‚’èª­ã¿å–ã‚Šã¾ã—ãŸ", "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®šã—ã¾ã—ãŸ");
              showToastNearBox("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ›´æ–°", pts);
              speakLineOnce(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ book ${state.currentTarget.book} ã€ ${state.currentTarget.wc} ã«è¨­å®šã—ã¾ã—ãŸã€‚`, { cooldown: 2500 });

              // â˜…locationãŒã¾ã ãªã‚‰å–ã‚‹
              if (!state.currentShelf) {
                fetchShelfFromGSheet(state.currentTarget.book, state.currentTarget.wc);
                // å–ã‚ŒãŸã‚‰ fetchShelfFromGSheet å´ã§ã—ã‚ƒã¹ã‚‹
              } else {
                // ã‚‚ã†ã‚ã‚‹ãªã‚‰ã“ã“ã§ã—ã‚ƒã¹ã‚‹
                promptScanShelf();
              }

              holdScan(800);
            }
          } else {
            drawBox(pts, CONFIG.colors.ng, "ä½œæ¥­æŒ‡ç¤ºï¼ˆå½¢å¼ä¸æ˜ï¼‰", 'dashed');
            updateHistory(raw, 'order', false);
          }

        } else {
          drawBox(pts, CONFIG.colors.ng, "åˆ¥QR", 'dashed');
          updateHistory(raw, 'other', false);
        }
      }

      if (!state.holdTimer) {
        let msg = "æ¢ç´¢ä¸­...";
        let statusType = "info";

        if (detections.length > 0) {
          if (anyMatch) {
            msg = "ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç™ºè¦‹";
            statusType = "ok";
          } else if (anyLocMatch) {
            msg = "ç›®çš„ã®æ£šã‚’æ¤œçŸ¥";
            statusType = "loc";
          } else {
            msg = `${detections.length}ä»¶æ¤œçŸ¥`;
            statusType = "ng";
          }
        }
        updateStatus(msg, statusType);
      }
    }

    async function tick() {
      if (!state.stream) return;
      if (DOM.video.readyState === DOM.video.HAVE_ENOUGH_DATA) {
        fitOverlay();
        const detections = await detectCombined();
        applyDetections(detections);
      }
      state.rafId = requestAnimationFrame(tick);
    }

    function updateStatus(text, type = 'info') {
      DOM.scanStatus.textContent = text;
      DOM.scanStatus.className = `badge chip ${type}`;
    }

    function showHistoryModal() {
      DOM.historyList.innerHTML = '';
      if (state.scanHistory.size === 0) {
        DOM.historyList.innerHTML = '<li>ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>';
      } else {
        const sortedHistory = Array.from(state.scanHistory.entries()).reverse();
        for (const [raw, data] of sortedHistory) {
          const li = document.createElement('li');
          let status = '';
          if (data.kind === 'die') {
            status = data.isMatch ? 'âœ”ï¸ ä¸€è‡´ (å‹)' : 'âŒ ä¸ä¸€è‡´ (å‹)';
          } else if (data.kind === 'loc') {
            status = data.isMatch ? 'âœ”ï¸ ä¸€è‡´ (æ£š)' : 'âŒ ä¸ä¸€è‡´ (æ£š)';
          } else if (data.kind === 'order') {
            status = data.isMatch ? 'ğŸ§¾ ä½œæ¥­æŒ‡ç¤º èª­ã¿å–ã‚Š' : 'ğŸ§¾ ä½œæ¥­æŒ‡ç¤º å½¢å¼ä¸æ˜';
          } else {
            status = 'â“ ãã®ä»–';
          }
          li.innerHTML = `<strong>${status}:</strong> ${raw.substring(0, 60)}${raw.length > 60 ? '...' : ''}`;
          DOM.historyList.appendChild(li);
        }
      }
      DOM.historyModal.style.display = 'block';
    }

    // æ‰‹å…¥åŠ›ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š
    function setTargetByManual(book, wc) {
      book = (book || '').trim();
      wc   = (wc   || '').trim();
      if (!book || !wc) {
        alert('book ã¨ wc ã‚’å…¥åŠ›ï¼ˆé¸æŠï¼‰ã—ã¦ãã ã•ã„');
        return;
      }

      state.currentTarget = { book, wc, wn: '' };
      state.targetKey = dieKey(book, wc);

      DOM.tgtBN.textContent = book;
      DOM.tgtWC.textContent = wc;
      DOM.tgtWN.textContent = '';

      updateStatus('ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š', 'ok');
      showBigMessage('æ‰‹å‹•ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š', `ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: Book=${book} / WC=${wc}`);
      speakLineOnce(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ book ${book} ã€ ${wc} ã«è¨­å®šã—ã¾ã—ãŸã€‚`);

      if (!state.currentShelf) {
        fetchShelfFromGSheet(book, wc);
        // å–å¾—ã§ããŸã‚‰ fetchShelfFromGSheet å´ã§ã—ã‚ƒã¹ã‚‹
      } else {
        // æ—¢ã«ã‚ã‚‹ãªã‚‰ã“ã“ã§ã—ã‚ƒã¹ã‚‹
        promptScanShelf();
      }
    }

    // ã‚¬ã‚¤ãƒ‰ã‚¹ã‚³ãƒ¼ãƒ—è¿½åŠ 
    function addTargetScope() {
      const existingScope = document.querySelector('.target-scope');
      if (existingScope) existingScope.remove();

      const scope = document.createElement('div');
      scope.className = 'target-scope';

      const cornerTL = document.createElement('div'); cornerTL.className = 'corner-tl'; scope.appendChild(cornerTL);
      const cornerTR = document.createElement('div'); cornerTR.className = 'corner-tr'; scope.appendChild(cornerTR);
      const cornerBL = document.createElement('div'); cornerBL.className = 'corner-bl'; scope.appendChild(cornerBL);
      const cornerBR = document.createElement('div'); cornerBR.className = 'corner-br'; scope.appendChild(cornerBR);

      const scanLine = document.createElement('div');
      scanLine.className = 'scan-line';
      scope.appendChild(scanLine);

      DOM.stack.appendChild(scope);
    }

    function initialize() {
      const params = new URLSearchParams(location.search);
      state.currentTarget = {
        book: (params.get("book") || "").trim(),
        wc: (params.get("wc") || "").trim(),
        wn: (params.get("wn") || "").trim()
      };

      if (!state.currentTarget.book || !state.currentTarget.wc) {
        updateStatus("ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæœªæŒ‡å®šï¼ˆä½œæ¥­æŒ‡ç¤ºQRã‚’èª­ã¿å–ã‚‹ã‹ã€æ‰‹å…¥åŠ›ã§æŒ‡å®šï¼‰", "ng");
        DOM.error.textContent = "URLã« ?book=...&wc=... ã‚’æŒ‡å®šã€ã¾ãŸã¯ä½œæ¥­æŒ‡ç¤ºQRï¼ˆorder_plainï¼‰/æ‰‹å…¥åŠ›ã§æŒ‡å®šã—ã¦ãã ã•ã„ã€‚";
        DOM.btnStart.disabled = false;
      } else {
        DOM.tgtBN.textContent = state.currentTarget.book;
        DOM.tgtWC.textContent = state.currentTarget.wc;
        DOM.tgtWN.textContent = state.currentTarget.wn;
        state.targetKey = dieKey(state.currentTarget.book, state.currentTarget.wc);
        updateStatus("æº–å‚™å®Œäº†");
      }

      const locParam = (params.get("loc") || "").trim();
      if (locParam) {
        state.currentShelf = locParam;
        DOM.currentShelf.textContent = state.currentShelf;
        DOM.currentShelf.className = "chip loc";
        // â˜…URLã§ã‚ã‹ã£ã¦ã„ã‚‹ã¨ãã‚‚ã—ã‚ƒã¹ã‚‹
        promptScanShelf();
      } else {
        if (state.currentTarget.book && state.currentTarget.wc) {
          fetchShelfFromGSheet(state.currentTarget.book, state.currentTarget.wc);
        }
      }

      // æ‰‹å…¥åŠ›å´ã«åˆæœŸå€¤åæ˜ 
      if (DOM.inBook && state.currentTarget.book) {
        const opt = Array.from(DOM.inBook.options).find(o => (o.value || '').toLowerCase() === state.currentTarget.book.toLowerCase());
        if (opt) DOM.inBook.value = opt.value;
      }
      if (DOM.inWc && state.currentTarget.wc) {
        DOM.inWc.value = state.currentTarget.wc;
      }

      addTargetScope();
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆ
    DOM.btnStart.addEventListener("click", () => {
      initTTS();
      unlockTTS();
      startCam();
    });
    DOM.btnStop.addEventListener("click", stopCam);
    DOM.btnHistory.addEventListener("click", showHistoryModal);
    DOM.closeModal.addEventListener("click", () => DOM.historyModal.style.display = 'none');
    window.addEventListener("click", (event) => { if (event.target == DOM.historyModal) DOM.historyModal.style.display = "none"; });
    DOM.fileTest.addEventListener("change", async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const img = new Image();
      img.onload = async () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.width; canvas.height = img.height;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const hits = jsqrMulti(imgData).map(h => ({ rawValue: h.rawValue, cornerPoints: h.cornerPoints }));
        DOM.overlay.width = img.width; DOM.overlay.height = img.height;
        applyDetections(hits);
        updateStatus(`é™æ­¢ç”»ãƒ†ã‚¹ãƒˆ: ${hits.length}ä»¶æ¤œçŸ¥`);
        ev.target.value = "";
      };
      img.src = URL.createObjectURL(file);
    });
    if (DOM.btnSetTarget) {
      DOM.btnSetTarget.addEventListener('click', () => {
        const book = DOM.inBook?.value || '';
        const wc   = DOM.inWc?.value   || '';
        setTargetByManual(book, wc);
      });
    }

    function jsqrMulti(imgData) {
      const hits = [];
      const maskedData = new Uint8ClampedArray(imgData.data);
      for (let k = 0; k < 10; k++) {
        const hit = jsQR(maskedData, imgData.width, imgData.height, { inversionAttempts: 'dontInvert' });
        if (!hit) break;
        hits.push({
          rawValue: hit.data,
          cornerPoints: [
            hit.location.topLeftCorner,
            hit.location.topRightCorner,
            hit.location.bottomRightCorner,
            hit.location.bottomLeftCorner
          ]
        });
        const { topLeftCorner, bottomRightCorner } = hit.location;
        for (let y = Math.floor(topLeftCorner.y); y < Math.ceil(bottomRightCorner.y); y++) {
          for (let x = Math.floor(topLeftCorner.x); x < Math.ceil(bottomRightCorner.x); x++) {
            const i = (y * imgData.width + x) * 4;
            maskedData[i] = maskedData[i + 1] = maskedData[i + 2] = 255;
          }
        }
      }
      return hits;
    }

    initialize();
  });
  </script>
</body>
</html>
