<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>抜型を探す（ターゲット強調）</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root { --ok:#1c7ed6; --ng:#e03131; --loc:#2e7d32; --bd:#ddd; --tx:#222; --sub:#666; }
  *{ box-sizing:border-box; }
  body{ font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin:10px; color:var(--tx); }
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start}
  .panel{flex:1 1 360px;min-width:320px}
  .stack{position:relative;max-width:720px}
  video{width:100%;max-width:720px;border:1px solid var(--bd);border-radius:12px;background:#000}
  #ov{position:absolute;inset:0;pointer-events:none; display:block}
  .controls{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0;align-items:center}
  button,.btn{padding:12px 16px;border-radius:12px;border:1px solid var(--bd);background:#fff;cursor:pointer}
  .pill{border-radius:999px}
  .badge{display:inline-block;border-radius:8px;padding:3px 8px;font-size:12px;background:#eef;color:#224}
  .target{font-size:15px}
  .target b{font-size:17px}
  .legend{font-size:12px;color:#555}
  .okChip{background:#e7f1ff;color:#1c7ed6;border:1px solid #a5c8ff;padding:0 6px;border-radius:6px}
  .ngChip{background:#fff5f5;color:#e03131;border:1px solid #ffc9c9;padding:0 6px;border-radius:6px}
  .locChip{background:#e9f7ef;color:#2e7d32;border:1px solid #b7e1c0;padding:0 6px;border-radius:6px}
  .muted{color:#666;font-size:12px}

  .fixedBar{
    position:fixed;left:10px;top:env(safe-area-inset-top,10px);
    background:#e8f5e9;color:#075a07; border:1px solid #8ad18a;
    padding:6px 10px;border-radius:10px;font-weight:800; font-size:20px; z-index:20;
  }

  #toast{ position:fixed; left:0; top:0; pointer-events:none; z-index:30; }
  .toast-bubble{
    position:absolute; background:rgba(255,255,255,.95); border:1px solid #ccc;
    border-radius:10px; padding:6px 10px; font-size:13px; box-shadow:0 3px 14px rgba(0,0,0,.18);
    transform:translate(-50%,-150%); white-space:nowrap;
  }

  /* ロック・オーバーレイ（フリーズ表示） */
  #holdLayer{
    position:absolute; inset:0; display:none;
    background:rgba(0,0,0,.25);
    align-items:center; justify-content:center; z-index:25; pointer-events:none;
  }
  #holdPanel{
    pointer-events:auto;
    background:#fff; color:#111; border:1px solid #ddd; border-radius:12px;
    padding:10px 14px; box-shadow:0 8px 24px rgba(0,0,0,.25); text-align:center;
  }
  #holdPanel .title{ font-weight:800; font-size:16px; margin-bottom:6px; color:#1c7ed6; }
  #holdPanel .sub{ font-size:12px; color:#555; }
  #btnUnlock{ margin-top:8px; }
  .topbar{display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap}
  .topbar-right{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  input[type="range"]{ width: 140px; }
</style>
</head>
<body>
  <div class="fixedBar" id="fixed">固定棚: （なし）</div>
  <div id="toast"></div>

  <div class="topbar">
    <h3 style="margin:6px 0 8px">棚→型の順にスキャン（目的の抜型をロック）</h3>
    <div class="topbar-right">
      <span id="cap" class="badge">準備中…</span>
      <button id="btnStart" class="pill">カメラ開始</button>
      <button id="btnStop"  class="pill" disabled>停止</button>
      <button id="btnTorch" style="display:none">ライト OFF</button>
      <label class="muted" style="display:flex;align-items:center;gap:6px;user-select:none">
        <span>ズーム</span><input id="zoom" type="range" style="display:none">
      </label>
    </div>
  </div>

  <div class="panel" style="margin-top:6px">
    <div class="target">
      目的の抜型：<b id="tgtBN">-</b> [<b id="tgtWC">-</b>] <span class="badge" id="tgtWN"></span>
      <div class="legend" style="margin-top:4px">
        <span class="okChip">青枠＝一致（ロック）</span>　
        <span class="ngChip">赤枠＝不一致</span>　
        <span class="locChip">緑枠＝LOC</span>
      </div>
    </div>
  </div>

  <div class="row" style="margin-top:8px">
    <div class="panel">
      <div class="stack" id="stack">
        <video id="v" playsinline muted></video>
        <canvas id="ov"></canvas>

        <!-- ロック中フリーズ表示 -->
        <div id="holdLayer">
          <div id="holdPanel">
            <div class="title">ロックしました</div>
            <div class="sub">数秒後に自動解除 / 解除ボタンで再スキャン</div>
            <button id="btnUnlock" class="pill">解除して再スキャン</button>
          </div>
        </div>
      </div>

      <div class="controls">
        <label class="badge">画像でテスト<input id="fileTest" type="file" accept="image/*" style="display:none" /></label>
      </div>
      <div id="status" class="muted">準備中…</div>
      <div id="err" class="muted" style="color:#b00;white-space:pre-wrap"></div>
    </div>

    <div class="panel">
      <div class="badge">ヒント</div>
      <div class="muted" style="margin-top:6px">
        ・URL で <code>?book=&wc=&wn=</code> を渡してください（Airtable の URL 型フィールド推奨）。<br>
        ・プレーン型 <code>die-Book-WorkCord</code> と URL型 <code>?book=&wc=</code> の両方を検知します。<br>
        ・一致時は<strong style="color:#1c7ed6">青枠＋音＋枠近くの吹き出し</strong>、不一致は赤枠、LOCは緑枠。<br>
        ・<code>&loc=</code> を付けると左上に固定棚表示。<br>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" crossorigin="anonymous"></script>
  <script>
  // ===== URLパラメータ =====
  const P = new URLSearchParams(location.search);
  const TGT = {
    book: (P.get("book")||"").trim(),
    wc:   (P.get("wc")||"").trim(),
    wn:   (P.get("wn")||"").trim(),
    loc:  (P.get("loc")||"").trim(),
  };
  document.getElementById("tgtBN").textContent = TGT.book || "-";
  document.getElementById("tgtWC").textContent = TGT.wc || "-";
  document.getElementById("tgtWN").textContent = TGT.wn || "";

  // 固定棚表示（任意）
  const fixedEl = document.getElementById("fixed");
  fixedEl.textContent = "固定棚: " + (TGT.loc || "（なし）");
  if(TGT.loc){
    fixedEl.style.background="#e6ffe6"; fixedEl.style.color="#086"; fixedEl.style.borderColor="#086";
  }

  // ===== 要素 =====
  const v   = document.getElementById("v");
  const ov  = document.getElementById("ov");
  const octx= ov.getContext("2d", { willReadFrequently:true });
  const statusEl = document.getElementById("status");
  const errEl    = document.getElementById("err");
  const capEl    = document.getElementById("cap");
  const toastLayer = document.getElementById("toast");
  const holdLayer  = document.getElementById("holdLayer");
  const btnUnlock  = document.getElementById("btnUnlock");
  const stack      = document.getElementById("stack");

  // ===== カメラ & 能力 =====
  let stream=null, detector=null, stopLoop=true;
  let videoTrack=null, camCaps=null;
  let frameSkip=0, SCAN_EVERY=2;

  // ロック保持
  let isHeld=false;
  let holdTimer=null;
  const HOLD_MS = 2200; // 自動解除までの停止時間

  // 状態
  let lockedOnce=false; // 連続ビープ抑制

  capEl.textContent = ('BarcodeDetector' in window) ? "BarcodeDetector + jsQR" : "jsQR only";

  // ===== カメラ制御 =====
  async function startCam(){
    stopCam(); setError("");
    const tries = [
      { video:{ facingMode:{exact:'environment'}, width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30} }, audio:false },
      { video:{ facingMode:'environment',           width:{ideal:1280}, height:{ideal:720},  frameRate:{ideal:30} }, audio:false },
      { video:{                                    width:{ideal:640},  height:{ideal:480} }, audio:false },
    ];
    for(const cons of tries){
      try{ stream = await navigator.mediaDevices.getUserMedia(cons); if(stream) break; }catch{}
    }
    if(!stream){ setError("❌ カメラ起動に失敗しました"); return; }

    v.srcObject = stream;
    try{ await v.play(); }catch(e){ setError(`❌ 再生失敗: ${e.message||e}`); return; }

    detector=null;
    if('BarcodeDetector' in window){
      try{ detector = new BarcodeDetector({ formats:['qr_code'] }); }catch{ detector=null; }
    }

    await bindCameraControls();

    stopLoop=false; lockedOnce=false;
    if(v.requestVideoFrameCallback){
      v.requestVideoFrameCallback(processFrame);
    }else{
      requestAnimationFrame(rAFLoop);
    }
    statusEl.textContent = (TGT.book && TGT.wc) ? "探索中…" : "URLに ?book と ?wc を付与してください";
  }

  function stopCam(){
    stopLoop = true;
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    document.getElementById("btnStart").disabled=false;
    document.getElementById("btnStop").disabled=true;
    clearHold();
    statusEl.textContent = "停止中";
  }

  function setError(t){ errEl.textContent = t || ""; }

  async function bindCameraControls(){
    const btnStart = document.getElementById("btnStart");
    const btnStop  = document.getElementById("btnStop");
    btnStart.disabled=true; btnStop.disabled=false;

    videoTrack = stream.getVideoTracks()[0];
    camCaps = videoTrack.getCapabilities?.() || {};

    // Torch
    const torchBtn = document.getElementById("btnTorch");
    if(camCaps.torch){
      torchBtn.style.display='inline-block';
      torchBtn.textContent = 'ライト OFF';
      torchBtn.onclick = async ()=>{
        const on = !(videoTrack.getConstraints().advanced?.[0]?.torch);
        await videoTrack.applyConstraints({ advanced:[{ torch:on }] });
        torchBtn.textContent = on ? 'ライト ON' : 'ライト OFF';
      };
    }else{
      torchBtn.style.display='none';
    }

    // Zoom
    const zoomSl = document.getElementById("zoom");
    if(typeof camCaps.zoom === 'number' || (camCaps.zoom && camCaps.zoom.min!=null)){
      const min = camCaps.zoom.min ?? 1, max = camCaps.zoom.max ?? 5, step = camCaps.zoom.step ?? 0.1;
      zoomSl.min=min; zoomSl.max=max; zoomSl.step=step; zoomSl.value = videoTrack.getSettings().zoom ?? min;
      zoomSl.style.display='inline-block';
      zoomSl.oninput = ()=> videoTrack.applyConstraints({ advanced:[{ zoom:Number(zoomSl.value) }] });
    }else{
      zoomSl.style.display='none';
    }
  }

  // ===== 成功音 =====
  const beep = (() => {
    let ctx; return () => {
      try{
        ctx = ctx || new (window.AudioContext||window.webkitAudioContext)();
        const o = ctx.createOscillator(), g = ctx.createGain();
        o.type="sine"; o.frequency.value=880; g.gain.value=0.001;
        o.connect(g); g.connect(ctx.destination);
        const now = ctx.currentTime;
        g.gain.setValueAtTime(0.001, now);
        g.gain.exponentialRampToValueAtTime(0.2, now+0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
        o.start(now); o.stop(now+0.2);
      }catch{}
    };
  })();

  // ===== 解析ユーティリティ =====
  function fitOverlay(){
    ov.width  = v.videoWidth  || ov.width;
    ov.height = v.videoHeight || ov.height;
    ov.style.width  = v.clientWidth + "px";
    ov.style.height = v.clientHeight + "px";
  }

  const classify = (s)=>{
    if(/^loc-/i.test(s)) return "loc";
    if(/^die-/i.test(s)) return "die";
    try{ const u=new URL(s); if(u.searchParams.get("book")||u.searchParams.get("wc")) return "die"; }catch{}
    return "other";
  };
  const parseDie = (text)=>{
    let m = /^die-([^-\n]+)-(.+)$/.exec(text);
    if(m) return { bn:m[1].trim(), wc:m[2].trim() };
    try{
      const u=new URL(text);
      const bn=(u.searchParams.get("book")||"").trim();
      const wc=(u.searchParams.get("wc")||"").trim();
      if(bn || wc) return { bn, wc };
    }catch{}
    return null;
  };
  const dieKey  = (bn,wc)=>`${(bn||"").trim()}@@${(wc||"").trim()}`;
  const tgtKey  = dieKey(TGT.book, TGT.wc);

  function showToastNearBox(text, pts){
    const rect = v.getBoundingClientRect();
    const scaleX = rect.width / (ov.width||v.videoWidth||1);
    const scaleY = rect.height/ (ov.height||v.videoHeight||1);
    const x = pts[1].x*scaleX + rect.left;
    const y = pts[1].y*scaleY + rect.top;
    const div = document.createElement('div');
    div.className='toast-bubble';
    div.textContent=text;
    div.style.left = x+'px';
    div.style.top  = y+'px';
    toastLayer.appendChild(div);
    setTimeout(()=>{ div.style.opacity='0'; div.style.transition='opacity .4s'; }, 900);
    setTimeout(()=>div.remove(), 1300);
  }

  // 色付き枠（毎回明示）
  function drawBoxPts(pts, color, lw, label){
    if(!pts) return;
    octx.save();
    octx.globalCompositeOperation = 'source-over';
    octx.lineJoin = 'round';
    octx.lineCap  = 'round';
    octx.shadowColor = 'rgba(0,0,0,.35)';
    octx.shadowBlur  = 2;
    octx.lineWidth = lw;
    octx.strokeStyle = color;
    octx.beginPath();
    octx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) octx.lineTo(pts[i].x, pts[i].y);
    octx.closePath(); octx.stroke();
    if(label){
      const x = (pts[0].x + pts[1].x)/2;
      const y = Math.min(pts[0].y, pts[1].y) - 8;
      octx.fillStyle = color; octx.font="14px system-ui"; octx.textAlign="center";
      octx.fillText(label, x, y<14?14:y);
    }
    octx.restore();
  }

  // マルチスケール検出 → 原寸再検証
  async function detectMultiScale(canvas){
    const W = canvas.width, H = canvas.height;
    const off = new OffscreenCanvas(W,H);
    const o2 = off.getContext('2d', { willReadFrequently:true });
    o2.filter = 'contrast(120%) brightness(110%)';
    o2.drawImage(canvas,0,0,W,H);

    const cand=[];

    if(detector){
      try{
        const hits = await detector.detect(off);
        for(const h of hits){
          if(h.rawValue){ cand.push({ raw:h.rawValue.trim(), pts:h.cornerPoints }); }
        }
      }catch{}
    }

    if(cand.length===0){
      const scales=[0.75,0.6,0.5];
      for(const s of scales){
        const sw=Math.max(320, Math.floor(W*s)), sh=Math.max(240, Math.floor(H*s));
        const small = new OffscreenCanvas(sw,sh);
        const sctx = small.getContext('2d', { willReadFrequently:true });
        sctx.imageSmoothingEnabled=false;
        sctx.drawImage(off, 0,0,sw,sh);
        const img=sctx.getImageData(0,0,sw,sh);
        const hit = jsQR(img.data, sw, sh, { inversionAttempts:'attemptBoth' });
        if(hit){
          const su=(p)=>({x:p.x*(W/sw), y:p.y*(H/sh)});
          cand.push({ raw: hit.data.trim(), pts: [su(hit.location.topLeftCorner),su(hit.location.topRightCorner),su(hit.location.bottomRightCorner),su(hit.location.bottomLeftCorner)], weak:true });
          break;
        }
      }
    }
    if(cand.length===0) return [];

    const confirmed=[];
    for(const c of cand){
      const xs=c.pts.map(p=>p.x), ys=c.pts.map(p=>p.y);
      const pad=24;
      const x0=Math.max(0, Math.min(...xs)-pad)|0, x1=Math.min(W, Math.max(...xs)+pad)|0;
      const y0=Math.max(0, Math.min(...ys)-pad)|0, y1=Math.min(H, Math.max(...ys)+pad)|0;
      const cw=x1-x0, ch=y1-y0; if(cw<30||ch<30) continue;
      const crop=new OffscreenCanvas(cw,ch);
      const crx=crop.getContext('2d', { willReadFrequently:true });
      crx.drawImage(off, x0,y0,cw,ch, 0,0,cw,ch);
      const img=crx.getImageData(0,0,cw,ch);
      const hit = jsQR(img.data, cw, ch, { inversionAttempts:'attemptBoth' });
      if(hit && hit.data){
        const loc=hit.location;
        const map=(p)=>({x:p.x+x0, y:p.y+y0});
        confirmed.push({ raw:hit.data.trim(), pts:[map(loc.topLeftCorner),map(loc.topRightCorner),map(loc.bottomRightCorner),map(loc.bottomLeftCorner)] });
      }else{
        confirmed.push(c);
      }
    }
    return confirmed;
  }

  // rVFC / rAF ループ
  async function processFrame(){
    if(stopLoop || !v.videoWidth){ if(!stopLoop) v.requestVideoFrameCallback(processFrame); return; }

    // ロック中は「描画のみ」して検出を止める（フリーズ表示）
    if(isHeld){ if(!stopLoop) v.requestVideoFrameCallback(processFrame); return; }

    fitOverlay();
    octx.clearRect(0,0,ov.width,ov.height);

    if((frameSkip++ % SCAN_EVERY)===0){
      const tmp = document.createElement('canvas');
      tmp.width = v.videoWidth; tmp.height = v.videoHeight;
      const tctx = tmp.getContext('2d', { willReadFrequently:true });
      tctx.drawImage(v,0,0,tmp.width,tmp.height);

      try{
        const det = await detectMultiScale(tmp);
        applyDetections(det);
      }catch{}
    }
    if(!stopLoop) v.requestVideoFrameCallback(processFrame);
  }
  function rAFLoop(){
    if(stopLoop || !v.videoWidth){ if(!stopLoop) requestAnimationFrame(rAFLoop); return; }
    if(isHeld){ if(!stopLoop) requestAnimationFrame(rAFLoop); return; } // ロック中は検出停止
    fitOverlay();
    octx.clearRect(0,0,ov.width,ov.height);
    if((frameSkip++ % SCAN_EVERY)===0){
      const tmp = document.createElement('canvas');
      tmp.width = v.videoWidth; tmp.height = v.videoHeight;
      const tctx = tmp.getContext('2d', { willReadFrequently:true });
      tctx.drawImage(v,0,0,tmp.width,tmp.height);
      detectMultiScale(tmp).then(applyDetections).catch(()=>{});
    }
    if(!stopLoop) requestAnimationFrame(rAFLoop);
  }

  // 適用・描画
  function applyDetections(list){
    let anyMatch=false;
    octx.clearRect(0,0,ov.width,ov.height);
    for(const d of (list||[])){
      const raw=(d.raw||"").trim(); if(!raw) continue;
      const kind = classify(raw);

      if(kind==="die"){
        const p = parseDie(raw);
        const key = p ? dieKey(p.bn,p.wc) : "";
        const isMatch = key && key.toLowerCase()===tgtKey.toLowerCase();
        anyMatch = anyMatch || isMatch;

        drawBoxPts(d.pts, isMatch? getCss('--ok') : (d.weak? '#ff7777' : getCss('--ng')), isMatch? 5 : 3, isMatch? "一致":"");

        if(isMatch && !lockedOnce){
          lockedOnce = true; beep(); showToastNearBox("ロック", d.pts);
          // ロック → 少しフリーズ
          holdNow();
        }
      }else if(kind==="loc"){
        drawBoxPts(d.pts, getCss('--loc'), 3, "LOC");
      }
    }
    statusEl.textContent = (list && list.length)
      ? (anyMatch ? "目的の抜型をロック中" : `検知 ${list.length} 件（不一致）`)
      : "探索中…";
  }

  function getCss(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || '#00f';
  }

  // ===== ロック保持（フリーズ → 解除可） =====
  function holdNow(){
    isHeld = true;
    holdLayer.style.display = 'flex';
    // 自動解除タイマー
    clearTimeout(holdTimer);
    holdTimer = setTimeout(clearHold, HOLD_MS);
  }
  function clearHold(){
    isHeld = false;
    holdLayer.style.display = 'none';
    clearTimeout(holdTimer); holdTimer=null;
    // 再ロックできるよう毎回リセット
    lockedOnce = false;
  }
  btnUnlock.addEventListener('click', clearHold);

  // ===== 画像テスト =====
  document.getElementById("fileTest").addEventListener("change", async (ev)=>{
    const f = ev.target.files?.[0]; if(!f) return;
    const img = new Image();
    img.onload = async ()=>{
      ov.width=img.width; ov.height=img.height; octx.clearRect(0,0,ov.width,ov.height);
      const tmp = document.createElement('canvas');
      tmp.width=img.width; tmp.height=img.height;
      const tctx = tmp.getContext('2d', { willReadFrequently:true });
      tctx.drawImage(img,0,0,tmp.width,tmp.height);
      const det = await detectMultiScale(tmp);
      applyDetections(det);
      ev.target.value="";
    };
    img.src = URL.createObjectURL(f);
  });

  // ボタン
  document.getElementById("btnStart").addEventListener("click", startCam);
  document.getElementById("btnStop").addEventListener("click", stopCam);

  // 初期
  statusEl.textContent = (TGT.book && TGT.wc) ? "カメラを開始してください" : "URLに ?book と ?wc を付与してください";
  </script>
</body>
</html>
