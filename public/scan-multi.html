<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>棚→型の順でスキャン（自動登録）</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root { --bd:#ddd; --tx:#222; --sub:#666; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 12px; color: var(--tx); }
  h2 { margin: 6px 0 12px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
  .view { position:relative; width: 360px; max-width: 100%; }
  video { width: 100%; border:1px solid var(--bd); border-radius:10px; background:#000; display:block; }
  canvas#det { display:none; }          /* 解析用(非表示) */
  canvas#ov  { position:absolute; inset:0; width:100%; height:100%; touch-action:none; }
  .panel { flex:1 1 340px; min-width:320px; }
  .controls { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0 14px; align-items:center; }
  button, .btn { padding: 11px 15px; border-radius: 12px; border:1px solid var(--bd); background:#fff; cursor:pointer; font-size: 1.2rem; line-height: 1.1; }
  .btn input[type="file"]{ display:none }
  .muted { color: var(--sub); font-size: 12px; }
  .list { margin-top:8px; }
  .item { border:1px solid var(--bd); border-radius:12px; padding:10px; margin-bottom:10px; }
  .head { font-weight:700; margin-bottom:6px; }
  .kv { font-size: 13px; }
  .sub { color: var(--sub); font-size:12px; }
  .actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; align-items:center; }
  .chip { display:inline-block; padding:4px 10px; border:1px solid var(--bd); border-radius:999px; font-size:12px; }
  .badge { display:inline-block; background:#eef; color:#224; padding:4px 8px; border-radius:6px; font-size:12px; }
  #err { color:#b00020; white-space:pre-wrap; }
  .pill { border-radius:999px; }
  .locBox { padding:10px; border:2px solid #0a0; border-radius:12px; background:#f7fff7; }
  .dieBox { padding:10px; border:1px solid #aaa; border-radius:10px; }
  .del { color:#b00; border-color:#f0c; }
  .toastWrap { position:fixed; right:10px; top:10px; display:flex; flex-direction:column; gap:8px; z-index:1000; }
  .toast { background:#111; color:#fff; padding:8px 12px; border-radius:10px; font-size:14px; opacity:.95; box-shadow:0 4px 16px rgba(0,0,0,.2); }
  .toast small{ color:#9cc; margin-left:6px; }

  /* === モーダル === */
  .modalMask { position:fixed; inset:0; background:rgba(0,0,0,.4); display:none; z-index:1200; }
  .modal { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); width:min(680px, 92vw); max-height:88vh; background:#fff; border-radius:14px; box-shadow:0 20px 80px rgba(0,0,0,.25); display:none; z-index:1300; overflow:auto; }
  .modalHdr { position:sticky; top:0; background:#fff; border-bottom:1px solid var(--bd); padding:12px 14px; display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .modalBody { padding:12px 14px; }
  .modalHdr h3 { margin:0; font-size:18px; }
  .closeX { border:none; background:#f4f4f4; border-radius:10px; padding:8px 10px; cursor:pointer; }
</style>
</head>
<body>
  <h2 style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
    棚→型の順でスキャン（自動登録）
    <button id="btnOpenList" class="pill">登録一覧を確認する</button>
  </h2>

  <div class="row">
    <div class="panel">
      <div class="view">
        <video id="v" playsinline muted></video>
        <canvas id="ov"></canvas>
      </div>
      <canvas id="det"></canvas>

      <div class="controls">
        <button id="btnStart">カメラ開始</button>
        <button id="btnStop" disabled>停止</button>
        <label class="btn">画像からテスト<input id="fileTest" type="file" accept="image/*"></label>
        <span id="cap" class="badge"></span>
      </div>

      <div class="muted" id="status">棚を先に、次に型をかざすと自動で固定されます。</div>
      <div id="err" class="muted"></div>
    </div>

    <div class="panel">
      <div class="locBox">
        <div><b>固定中の棚（LOC）</b></div>
        <div id="locLabel" class="kv" style="margin:6px 0 8px">（未選択）</div>
        <div class="controls">
          <button id="btnClearLoc" class="pill">棚を解除</button>
        </div>
      </div>

      <div style="margin:12px 0 6px"><b>固定した型（DIE）</b></div>
      <div id="dieList" class="list"></div>

      <div class="controls">
        <button id="btnUpdate" class="pill">確定リンクを Google Sheets に更新</button>
        <button id="btnClearDies" class="pill">型リストを全消去</button>
      </div>
    </div>
  </div>

  <!-- モーダル：登録一覧 -->
  <div id="mask" class="modalMask"></div>
  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modalHdr">
      <h3 id="modalTitle">登録一覧</h3>
      <button id="btnCloseList" class="closeX">閉じる</button>
    </div>
    <div class="modalBody">
      <div class="locBox" style="margin-bottom:10px">
        <div><b>固定中の棚（LOC）</b></div>
        <div id="locLabel2" class="kv" style="margin:6px 0 8px">（未選択）</div>
        <div class="controls">
          <button id="btnClearLoc2" class="pill">棚を解除</button>
        </div>
      </div>

      <div style="margin:12px 0 6px"><b>固定した型（DIE）</b></div>
      <div id="dieList2" class="list"></div>

      <div class="controls" style="position:sticky;bottom:0;background:#fff;padding-bottom:12px">
        <button id="btnUpdate2" class="pill">確定リンクを Google Sheets に更新</button>
        <button id="btnClearDies2" class="pill">型リストを全消去</button>
      </div>
    </div>
  </div>

  <div class="toastWrap" id="toasts"></div>

  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" crossorigin="anonymous"></script>
  <script>
  // ========= 設定 =========
  const SHEET_ENDPOINT = "/api/gsheet-seen-bulk";
  const params = new URLSearchParams(location.search);
  const FORCE_LEGACY = params.get("legacy")==="1";
  const SCAN_SCALE = 2;

  // ========= 状態 =========
  let fixedLoc = null;                   // {loc, raw}
  const fixedDies = new Map();           // key=book-wc -> {bn,wc,wn?,raw,addedAt}
  const flashes = [];                    // ロック確定時フラッシュ
  const bubbles = [];                    // 近接バブル [{text,x,y,until,color,stroke}]
  let candidates = [];                   // [{kind,raw,parsed,corners,registered}]

  // ========= ユーティリティ =========
  const $ = (q)=>document.querySelector(q);
  const v = $("#v"), det = $("#det"), ov = $("#ov");
  const octx = ov.getContext("2d");
  const dctx = det.getContext("2d", { willReadFrequently: true });
  const cap = $("#cap"), statusEl = $("#status"), errEl = $("#err");
  const toasts = $("#toasts");
  const dieKey = (bn,wc)=>`${bn}-${wc}`;

  function setStatus(t){ statusEl.textContent = t; }
  function setError(t){ errEl.textContent = t || ""; }
  function escapeHtml(s){ return String(s??'').replace(/[&<>"]/g,c=>({ '&':'&amp;','<':'&gt;','>':'&gt;','"':'&quot;' }[c])); }

  // WorkName を URL の #d= base64url JSON から抽出
  function tryExtractWN(raw){
    try{
      const u = new URL(raw);
      const m = /[#&]d=([^&]+)/.exec(u.hash||"");
      if(!m) return "";
      const b64 = m[1].replace(/-/g,'+').replace(/_/g,'/');
      const pad = b64.length%4 ? '='.repeat(4-(b64.length%4)) : '';
      const json = atob(b64 + pad);
      const obj = JSON.parse(json);
      return (obj.wn||"").trim();
    }catch{ return ""; }
  }

  function classify(s){
    if(/^loc-/i.test(s)) return "loc";
    if(/^die-/i.test(s)) return "die";
    try{ const u=new URL(s); if(u.searchParams.get("book")||u.searchParams.get("wc")) return "die"; }catch{}
    return "other";
  }
  function parse(text){
    const m = /^die-([^-\n]+)-(.+)$/.exec(text);
    if(m){ return { bn:m[1].trim(), wc:m[2].trim(), wn:"" }; }
    try{
      const u=new URL(text);
      const book=(u.searchParams.get("book")||"").trim();
      const wc=(u.searchParams.get("wc")||"").trim();
      if(book||wc){ return { bn:book, wc:wc, wn: tryExtractWN(text) }; }
    }catch{}
    const l=/^loc-(.+)$/i.exec(text);
    if(l){ return { loc:l[1].trim() }; }
    return {};
  }

  function toast(msg, sub=""){
    const el = document.createElement("div");
    el.className = "toast";
    el.innerHTML = `${msg}${sub?` <small>${sub}</small>`:""}`;
    toasts.appendChild(el);
    setTimeout(()=>{ el.style.opacity="0"; el.style.transform="translateY(-6px)"; }, 1200);
    setTimeout(()=>{ el.remove(); }, 1800);
  }

  // 音＆バイブ
  let AC=null;
  function playBeep(freq=880, dur=120){
    try{
      if(!AC) AC = new (window.AudioContext||window.webkitAudioContext)();
      const o=AC.createOscillator(), g=AC.createGain();
      o.type="sine"; o.frequency.value=freq;
      g.gain.value=0.0001;
      o.connect(g); g.connect(AC.destination);
      const t=AC.currentTime;
      g.gain.exponentialRampToValueAtTime(0.08, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur/1000);
      o.start(); o.stop(t+dur/1000+0.02);
    }catch{}
  }
  function buzz(ms=60){ if(navigator.vibrate) navigator.vibrate(ms); }

  // ========= 描画 =========
  function drawPolygon(ctx, points){
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.closePath();
  }

  function centroid(corners){
    const xs=corners.map(p=>p.x), ys=corners.map(p=>p.y);
    return { x:(Math.min(...xs)+Math.max(...xs))/2, y:Math.min(...ys) };
  }

  function roundedRect(ctx, x,y,w,h,r=10){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawOverlays(){
    octx.clearRect(0,0,ov.width,ov.height);

    // 候補：未登録は薄色、登録済みは点線
    for(const c of candidates){
      const isLoc = c.kind==='loc';
      if(c.registered){
        octx.setLineDash([8,6]);
        octx.lineWidth = 4;
        octx.strokeStyle = isLoc ? 'rgba(0,160,0,0.95)' : 'rgba(0,80,240,0.95)';
        octx.fillStyle   = isLoc ? 'rgba(0,200,0,0.12)' : 'rgba(0,120,255,0.12)';
      }else{
        octx.setLineDash([]);
        octx.lineWidth = 2;
        octx.strokeStyle = isLoc ? 'rgba(0,140,0,0.7)' : 'rgba(0,60,220,0.7)';
        octx.fillStyle   = isLoc ? 'rgba(0,180,0,0.18)' : 'rgba(0,90,255,0.18)';
      }
      drawPolygon(octx, c.corners);
      octx.stroke(); octx.fill();
    }

    // フラッシュ（ロック確定）
    for(let i=flashes.length-1; i>=0; i--){
      const f = flashes[i];
      const remain = f.until - performance.now();
      if(remain <= 0){ flashes.splice(i,1); continue; }
      const t = Math.max(0, Math.min(1, remain/1200));
      const color = f.kind==='loc' ? `rgba(0,180,0,${0.2+0.6*t})` : `rgba(0,90,255,${0.2+0.6*t})`;
      const stroke = f.kind==='loc' ? `rgba(0,140,0,${0.6+0.4*t})` : `rgba(0,60,220,${0.6+0.4*t})`;
      octx.fillStyle = color;
      octx.strokeStyle = stroke;
      octx.lineWidth = 4 + 4*t;
      drawPolygon(octx, f.corners);
      octx.stroke(); octx.fill();
    }

    // 近接バブル（枠の近くにメッセージ）
    for(let i=bubbles.length-1; i>=0; i--){
      const b = bubbles[i];
      const remain = b.until - performance.now();
      if(remain <= 0){ bubbles.splice(i,1); continue; }
      const t = Math.max(0, Math.min(1, remain/1600));
      const alpha = 0.9 * t;
      const padX=10, padY=6;

      octx.font = '16px system-ui, sans-serif';
      const metrics = octx.measureText(b.text);
      const w = metrics.width + padX*2;
      const h = 24 + padY*2;

      // 位置（画面外に出ないように調整）
      let x = b.x - w/2;
      let y = b.y - h - 8;
      x = Math.max(6, Math.min(x, ov.width - w - 6));
      y = Math.max(6, Math.min(y, ov.height - h - 6));

      octx.globalAlpha = alpha;
      octx.fillStyle = b.color;
      octx.strokeStyle = b.stroke;
      octx.lineWidth = 2;
      roundedRect(octx, x, y, w, h, 10);
      octx.fill();
      octx.stroke();

      // テキスト
      octx.fillStyle = '#fff';
      octx.textBaseline='middle';
      octx.textAlign='center';
      octx.fillText(b.text, x + w/2, y + h/2);
      octx.globalAlpha = 1;
    }
  }

  function addFlash(kind, corners){
    flashes.push({ kind, corners, until: performance.now()+1200 });
  }

  function addBubble(kind, corners, text){
    const c = centroid(corners);
    const color = kind==='loc' ? 'rgba(10,140,10,0.92)' : 'rgba(20,80,200,0.92)';
    const stroke= kind==='loc' ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.9)';
    bubbles.push({ text, x:c.x, y:c.y, color, stroke, until: performance.now()+1600 });
  }

  function renderLoc(){
    $("#locLabel").textContent  = fixedLoc ? fixedLoc.loc : "（未選択）";
    $("#locLabel2").textContent = fixedLoc ? fixedLoc.loc : "（未選択）";
  }

  function renderDies(){
    const build = () => [...fixedDies.values()].map(d=>{
      const key = `${d.bn}-${d.wc}`;
      const wn = d.wn ? ` / <span class="sub">WorkName: ${escapeHtml(d.wn)}</span>` : '';
      return `<div class="item dieBox" data-key="${key}">
        <div class="head">抜型 <span class="sub">${escapeHtml(d.bn)}</span> [<b>${escapeHtml(d.wc)}</b>]${wn}</div>
        <div class="actions">
          <button class="btn del" data-del="${key}">この型を削除</button>
          <span class="chip">${d.raw.length>70?escapeHtml(d.raw.slice(0,70))+"…":escapeHtml(d.raw)}</span>
        </div>
      </div>`;
    }).join("") || `<div class="muted">（まだ型はありません）</div>`;

    $("#dieList").innerHTML  = build();
    $("#dieList2").innerHTML = build();

    const bind = (rootSel) => {
      document.querySelectorAll(`${rootSel} button[data-del]`).forEach(b=>{
        b.onclick = ()=>{
          fixedDies.delete(b.dataset.del);
          renderDies();
        };
      });
    };
    bind("#dieList");
    bind("#dieList2");
  }

  // ========= 検出 =========
  let stream=null, rafId=null, detector=null, useBD=('BarcodeDetector' in window) && !FORCE_LEGACY;
  cap.textContent = useBD ? "BarcodeDetector + jsQR" : "jsQR only (legacy)";

  function stopCam(){
    cancelAnimationFrame(rafId); rafId=null;
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    $("#btnStart").disabled=false; $("#btnStop").disabled=true;
    setStatus("停止中");
  }
  function showError(e){ console.error(e); setError(`❌ ${e.name||''} ${e.message||e}`); }

  async function startCam(){
    stopCam(); setError("");
    const idealW = FORCE_LEGACY ? 640 : 1280;
    const idealH = FORCE_LEGACY ? 480 : 720;
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode:{ ideal:'environment' }, width:{ideal:idealW}, height:{ideal:idealH} }, audio:false
      });
    }catch(e){ showError(e); return; }
    v.srcObject=stream;
    try{ await v.play(); }catch(e){ showError(e); return; }

    const w = v.videoWidth || idealW, h = v.videoHeight || idealH;
    ov.width = w; ov.height = h;
    det.width = Math.floor(w); det.height = Math.floor(h);

    $("#btnStart").disabled=true; $("#btnStop").disabled=false;
    detector=null; if(useBD){ try{ detector=new BarcodeDetector({ formats:['qr_code'] }); }catch{ useBD=false; detector=null; } }
    tick();
  }

  function jsqrMulti(imgData, w, h, max=12){
    const out=[], data = new Uint8ClampedArray(imgData.data); // コピー
    const maskRect = loc=>{
      const xs=[loc.topLeftCorner.x,loc.topRightCorner.x,loc.bottomRightCorner.x,loc.bottomLeftCorner.x];
      const ys=[loc.topLeftCorner.y,loc.topRightCorner.y,loc.bottomRightCorner.y,loc.bottomLeftCorner.y];
      const x0=Math.max(0,Math.min(...xs)|0), x1=Math.min(w,Math.max(...xs)|0);
      const y0=Math.max(0,Math.min(...ys)|0), y1=Math.min(h,Math.max(...ys)|0);
      for(let y=y0;y<y1;y++){ for(let x=x0;x<x1;x++){ const i=(y*w+x)*4; data[i]=data[i+1]=data[i+2]=255; data[i+3]=255; } }
    };
    for(let k=0;k<max;k++){
      const hit = jsQR(data, w, h, { inversionAttempts:'attemptBoth' });
      if(!hit) break;
      out.push({
        raw: hit.data,
        corners: [hit.location.topLeftCorner,hit.location.topRightCorner,hit.location.bottomRightCorner,hit.location.bottomLeftCorner]
      });
      maskRect(hit.location);
    }
    return out;
  }

  async function detectOnce(){
    const ow = det.width * SCAN_SCALE, oh = det.height * SCAN_SCALE;
    const off = new OffscreenCanvas(ow, oh);
    const octx2 = off.getContext("2d", { willReadFrequently:true });
    octx2.imageSmoothingEnabled=false;
    octx2.filter = "contrast(120%) brightness(105%)";
    octx2.drawImage(v,0,0,ow,oh);

    const found=[]; const seen=new Set();

    if(useBD && detector){
      try{
        const codes=await detector.detect(off);
        for(const b of codes){
          const raw=b.rawValue.trim();
          if(seen.has(raw)) continue;
          seen.add(raw);
          const cs=b.cornerPoints.map(p=>({x:p.x/SCAN_SCALE, y:p.y/SCAN_SCALE}));
          found.push({ raw, corners:cs });
        }
      }catch{ useBD=false; detector=null; }
    }

    const imgData=octx2.getImageData(0,0,ow,oh);
    for(const h of jsqrMulti(imgData, ow, oh, 14)){
      const raw=h.raw.trim();
      if(seen.has(raw)) continue;
      seen.add(raw);
      const cs=h.corners.map(p=>({x:p.x/SCAN_SCALE, y:p.y/SCAN_SCALE}));
      found.push({ raw, corners:cs });
    }
    return found;
  }

  function refreshCandidates(hits){
    const next=[];
    for(const h of hits){
      const kind = classify(h.raw);
      const parsed = parse(h.raw);
      if(kind==='loc' && parsed.loc){
        const registered = !!(fixedLoc && fixedLoc.loc === parsed.loc);
        next.push({ kind, raw:h.raw, parsed, corners:h.corners, registered });
      }else if(kind==='die' && parsed.bn && parsed.wc){
        const key = dieKey(parsed.bn, parsed.wc);
        const registered = fixedDies.has(key);
        next.push({ kind, raw:h.raw, parsed, corners:h.corners, registered });
      }
    }
    candidates = next;
  }

  // 自動ロック：棚→型の順
  function autoLock(){
    // 棚
    if(!fixedLoc){
      const cLoc = candidates.find(c=>c.kind==='loc' && !c.registered);
      if(cLoc){
        fixedLoc = { loc:cLoc.parsed.loc, raw:cLoc.raw };
        renderLoc();
        addFlash('loc', cLoc.corners);
        addBubble('loc', cLoc.corners, '棚を固定');
        playBeep(660,130); buzz(40); toast("棚を固定", cLoc.parsed.loc);
      }
    }
    // 型（棚が固定済みのときのみ）
    if(fixedLoc){
      for(const c of candidates){
        if(c.kind!=='die') continue;
        const key = dieKey(c.parsed.bn, c.parsed.wc);
        if(!fixedDies.has(key)){
          const wn = c.parsed.wn || tryExtractWN(c.raw) || "";
          fixedDies.set(key, { bn:c.parsed.bn, wc:c.parsed.wc, wn, raw:c.raw, addedAt:Date.now() });
          renderDies();
          addFlash('die', c.corners);
          addBubble('die', c.corners, '型を登録');
          playBeep(880,120); buzz(30); toast("型を追加", `${c.parsed.bn}-${c.parsed.wc}`);
        }
      }
    }
  }

  async function tick(){
    if(!stream) return;
    const hits = await detectOnce();
    refreshCandidates(hits);
    autoLock();
    drawOverlays();
    rafId=requestAnimationFrame(tick);
  }

  // ========= 画像からテスト =========
  $("#fileTest").addEventListener("change", async (ev)=>{
    const f = ev.target.files?.[0]; if(!f) return;
    const img = new Image();
    img.onload = async ()=>{
      ov.width = img.width; ov.height = img.height;
      det.width = img.width; det.height = img.height;
      const off = new OffscreenCanvas(img.width, img.height);
      const ctx0 = off.getContext("2d");
      ctx0.drawImage(img,0,0);
      const imgData = ctx0.getImageData(0,0,img.width,img.height);
      const list = jsqrMulti(imgData, img.width, img.height, 14).map(h=>({
        raw:h.raw.trim(),
        corners:[h.corners?.[0]||h.location?.topLeftCorner,h.corners?.[1]||h.location?.topRightCorner,h.corners?.[2]||h.location?.bottomRightCorner,h.corners?.[3]||h.location?.bottomLeftCorner].map(p=>({x:p.x,y:p.y}))
      }));
      const cand = [];
      for(const h of list){
        const kind = classify(h.raw);
        const p = parse(h.raw);
        if(kind==="loc" && p.loc){ cand.push({kind, raw:h.raw, parsed:p, corners:h.corners, registered:false}); }
        else if(kind==="die" && p.bn && p.wc){
          const key=dieKey(p.bn,p.wc); const reg=fixedDies.has(key);
          cand.push({kind, raw:h.raw, parsed:p, corners:h.corners, registered:reg});
        }
      }
      candidates = cand;
      autoLock();
      drawOverlays();
      ev.target.value="";
    };
    img.src = URL.createObjectURL(f);
  });

  // ========= YYYY-MM-DD 送信共通 =========
  async function submitUpdate(){
    if(!fixedLoc){ alert("棚（LOC）が未選択です。先に loc-... を固定してください。"); return; }
    if(!fixedDies.size){ alert("型が1件もありません。die-... または ?book=&wc= を読み取ってください。"); return; }
    const now = new Date();
    const y = now.getFullYear(), m=String(now.getMonth()+1).padStart(2,'0'), d=String(now.getDate()).padStart(2,'0');
    const captured_date = `${y}-${m}-${d}`;
    const items = [...fixedDies.values()].map(d=>({ book:d.bn, wc:d.wc, wn:d.wn||"", loc:fixedLoc.loc, captured_at: captured_date }));
    const msg = items.map(p=>`• ${p.book}-${p.wc} → ${p.loc}`).join("\n");
    if(!confirm(`以下を Google Sheets に反映します。\n\n${msg}\n\n実行しますか？`)) return;
    try{
      const r = await fetch(SHEET_ENDPOINT, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ items }) });
      if(!r.ok) throw new Error(await r.text());
      const j = await r.json();
      if(!j.ok) throw new Error(JSON.stringify(j));
      toast("Google Sheets 更新完了");
      setStatus("更新しました。");
      playBeep(520,140);
    }catch(e){ alert("更新に失敗しました: " + (e.message||e)); }
  }

  // ========= ボタン =========
  $("#btnStart").addEventListener("click", startCam);
  $("#btnStop").addEventListener("click", stopCam);
  $("#btnClearLoc").addEventListener("click", ()=>{ fixedLoc=null; renderLoc(); });
  $("#btnClearDies").addEventListener("click", ()=>{ fixedDies.clear(); renderDies(); });
  $("#btnUpdate").addEventListener("click", submitUpdate);

  // ========= モーダル =========
  const mask  = $("#mask");
  const modal = $("#modal");
  function openList(){ renderLoc(); renderDies(); mask.style.display = "block"; modal.style.display = "block"; }
  function closeList(){ mask.style.display = "none"; modal.style.display = "none"; }
  $("#btnOpenList").addEventListener("click", openList);
  $("#btnCloseList").addEventListener("click", closeList);
  mask.addEventListener("click", closeList);
  $("#btnClearLoc2").addEventListener("click", ()=>{ fixedLoc=null; renderLoc(); });
  $("#btnClearDies2").addEventListener("click", ()=>{ fixedDies.clear(); renderDies(); });
  $("#btnUpdate2").addEventListener("click", submitUpdate);

  // ========= 初期 =========
  (async ()=>{ setStatus("棚→型の順でカメラにかざしてください。登録済みは点線枠、ロック時は枠の近くにバブル表示。"); })();
  </script>
</body>
</html>
