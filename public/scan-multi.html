<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>棚→型の順でスキャン（自動登録）</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<style>
  :root { --bd:#ddd; --tx:#222; --sub:#666; --ok:#0a0; --die:#e33; --done:#09f; }
  * { box-sizing: border-box; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 12px; color: var(--tx); }
  h2 { margin: 6px 0 12px; font-size: 18px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
  video { width: 360px; max-width: 100%; border:1px solid var(--bd); border-radius:10px; background:#000; }
  canvas { display:none; }
  .panel { flex:1 1 340px; min-width:320px; }
  .controls { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0 12px; align-items:center; }
  button, .btn {
    padding: 11px 15px; /* 20%大きく */
    border-radius: 12px; border:1px solid var(--bd); background:#fff; cursor:pointer; font-size: 15px;
  }
  .btn-primary { background:#f6faff; border-color:#b8d4ff; }
  .pill { border-radius:999px; }
  .muted { color: var(--sub); font-size: 12px; }
  .list { margin-top:8px; }
  .item { border:1px solid var(--bd); border-radius:12px; padding:10px; margin-bottom:10px; }
  .head { font-weight:700; margin-bottom:6px; }
  .actions { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; align-items:center; }
  .chip { display:inline-block; padding:4px 8px; border:1px solid var(--bd); border-radius:999px; font-size:12px; background:#fafafa; }
  .badge { display:inline-block; background:#eef; color:#224; padding:3px 8px; border-radius:6px; font-size:12px; }
  .locBox { padding:10px; border:2px solid var(--ok); border-radius:12px; background:#f7fff7; }
  .dieBox { padding:10px; border:1px solid #aaa; border-radius:10px; }
  .del { color:#b00; border-color:#f0c; }

  /* 画面オーバーレイ表示（固定棚ラベル） */
  #fixedBanner {
    position: fixed; left: 10px; top: env(safe-area-inset-top,10px);
    background:#eaffea; color:#075a07; border:1px solid #8ad18a; border-radius:10px;
    padding: 6px 10px; font-weight: 800; font-size: 22px; /* 2倍相当 */
    z-index: 20; box-shadow: 0 2px 6px rgba(0,0,0,.08);
  }
  #toast {
    position: fixed; left: 0; top: 0; pointer-events: none; z-index: 30;
  }
  .toast-bubble {
    position: absolute; background: rgba(255,255,255,.95); border:1px solid var(--bd);
    border-radius: 10px; padding: 6px 10px; font-size: 13px; box-shadow: 0 3px 14px rgba(0,0,0,.18);
    transform: translate(-50%, -150%); white-space: nowrap;
  }

  /* 上部操作バー（ボタンを右寄せにして隠れにくく） */
  .topbar { display:flex; justify-content: space-between; align-items:center; gap:8px; flex-wrap:wrap; }
  .topbar-right { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  #cap { font-size: 12px; }
  input[type="range"] { width: 140px; }
</style>
</head>
<body>
  <!-- 固定棚ラベル（常時表示） -->
  <div id="fixedBanner">固定棚: （未選択）</div>
  <!-- トースト出す用のコンテナ -->
  <div id="toast"></div>

  <div class="topbar">
    <h2>棚→型の順でスキャン（自動登録）</h2>
    <div class="topbar-right">
      <button id="btnList" class="btn btn-primary">スキャン結果確認</button>
      <button id="btnStart" class="btn btn-primary">カメラ開始</button>
      <button id="btnStop" class="btn">停止</button>
      <button id="btnTorch" style="display:none">ライト OFF</button>
      <label class="muted" style="display:flex;align-items:center;gap:6px;user-select:none">
        <span>ズーム</span><input id="zoom" type="range" style="display:none">
      </label>
      <span id="cap" class="badge"></span>
    </div>
  </div>

  <div class="row">
    <div class="panel">
      <video id="v" playsinline muted></video>
      <canvas id="c"></canvas>

      <div class="controls">
        <label class="btn">画像からテスト<input id="fileTest" type="file" accept="image/*" style="display:none"></label>
        <div class="muted" id="status">準備中…</div>
        <div id="err" class="muted"></div>
      </div>

      <div class="muted">
        ・棚QR：<b>loc-LOC-…</b>（プレーン） / 型QR：<b>die-BookName-WorkCord</b> または <b>?book=&wc=</b><br>
        ・棚を固定 → 対象棚の型を順次読み取り（自動登録） → 不要な型は個別削除 → 一括更新
      </div>
    </div>

    <div class="panel">
      <div class="locBox">
        <div><b>固定中の棚（LOC）</b></div>
        <div id="locLabel" class="kv" style="margin:6px 0 8px;font-size:16px">（未選択）</div>
        <div class="controls">
          <button id="btnClearLoc" class="pill">棚を解除</button>
        </div>
      </div>

      <div style="margin:12px 0 6px"><b>固定した型（DIE）</b></div>
      <div id="dieList" class="list"></div>

      <div class="controls">
        <button id="btnUpdate" class="pill btn-primary">確定リンクを Google Sheets に更新</button>
        <button id="btnClearDies" class="pill">型リストを全消去</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" crossorigin="anonymous"></script>
  <script>
  // ========= 設定 =========
  const SHEET_ENDPOINT = "/api/gsheet-seen-bulk"; // POST: {items:[{book,wc,loc,captured_at}]}
  const params = new URLSearchParams(location.search);
  const FORCE_LEGACY = params.get("legacy")==="1";

  // ========= 状態 =========
  let fixedLoc = null; // {loc, raw}
  const fixedDies = new Map(); // key=bn-wc -> {bn,wc,raw,addedAt}
  const recentSeen = new Map(); // raw -> ts (短時間の再処理抑制)

  // ========= ユーティリティ =========
  const $ = (q)=>document.querySelector(q);
  const v = $("#v"), c = $("#c");
  const ctx = c.getContext("2d", { willReadFrequently:true });
  const cap = $("#cap"), statusEl = $("#status"), errEl = $("#err");
  const toastLayer = $("#toast");
  function setStatus(t){ statusEl.textContent = t; }
  function setError(t){ errEl.textContent = t || ""; }

  function classify(s){
    if(/^loc-/i.test(s)) return "loc";
    if(/^die-/i.test(s)) return "die";
    try{ const u=new URL(s); if(u.searchParams.get("book")||u.searchParams.get("wc")) return "die"; }catch{}
    return "other";
  }
  function parse(text){
    const m = /^die-([^-\n]+)-(.+)$/.exec(text);
    if(m){ return { bn:m[1].trim(), wc:m[2].trim() }; }
    try{
      const u=new URL(text);
      const book=(u.searchParams.get("book")||"").trim();
      const wc=(u.searchParams.get("wc")||"").trim();
      if(book||wc){ return { bn:book, wc:wc }; }
    }catch{}
    const l=/^loc-(.+)$/i.exec(text);
    if(l){ return { loc:l[1].trim() }; }
    return {};
  }
  const dieKey = (bn,wc)=>`${bn}-${wc}`;
  function isAlreadyRegistered(raw){
    const p = parse(raw); if(!p.bn || !p.wc) return false;
    return fixedDies.has(dieKey(p.bn,p.wc));
  }

  function renderLoc(){
    const label = fixedLoc ? fixedLoc.loc : "（未選択）";
    $("#locLabel").textContent = label;
    $("#fixedBanner").textContent = `固定棚: ${label}`;
  }
  function renderDies(){
    const box = $("#dieList");
    const rows = [...fixedDies.values()].map(d=>{
      const key = dieKey(d.bn,d.wc);
      return `<div class="item dieBox" data-key="${key}">
        <div class="head">抜型 <span style="color:#666">${d.bn}</span> [<b>${d.wc}</b>]</div>
        <div class="actions">
          <button class="btn del" data-del="${key}">この型を削除</button>
          <span class="chip">${d.raw.length>70?d.raw.slice(0,70)+"…":d.raw}</span>
        </div>
      </div>`;
    }).join("") || `<div class="muted">（まだ型はありません）</div>`;
    box.innerHTML = rows;
    box.querySelectorAll("button[data-del]").forEach(b=>{
      b.onclick = ()=>{ fixedDies.delete(b.dataset.del); renderDies(); };
    });
  }

  // ====== トースト（ボックス近くに出す） ======
  function showToastNearBox(text, box, color='black'){
    if(!box || !box.length) return;
    const pts = box;
    // 右上の少し上に表示
    const x = pts[1].x, y = pts[1].y;
    const div = document.createElement('div');
    div.className='toast-bubble';
    div.textContent = text;
    div.style.borderColor = '#ccc';
    div.style.color = color;
    // video の相対座標をページ座標に
    const rect = v.getBoundingClientRect();
    const scaleX = rect.width / v.videoWidth;
    const scaleY = rect.height / v.videoHeight;
    div.style.left = (rect.left + x*scaleX) + 'px';
    div.style.top  = (rect.top  + y*scaleY) + 'px';
    toastLayer.appendChild(div);
    setTimeout(()=>{ div.style.opacity='0'; div.style.transition='opacity .4s'; }, 1000);
    setTimeout(()=>div.remove(), 1500);
  }

  // ========= カメラ =========
  let stream=null, detector=null, stopLoop=true;
  let videoTrack=null, imageCapture=null, camCaps=null;
  cap.textContent = ('BarcodeDetector' in window && !FORCE_LEGACY) ? "BarcodeDetector + jsQR" : "jsQR only (legacy)";

  async function startCam(){
    stopCam(); setError("");
    const tries = [
      { video:{ facingMode:{exact:'environment'}, width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30} }, audio:false },
      { video:{ facingMode:'environment',           width:{ideal:1280}, height:{ideal:720},  frameRate:{ideal:30} }, audio:false },
      { video:{                                    width:{ideal:640},  height:{ideal:480} }, audio:false },
    ];
    for(const cons of tries){
      try{ stream = await navigator.mediaDevices.getUserMedia(cons); if(stream) break; }catch{}
    }
    if(!stream){ setError("❌ カメラ起動に失敗しました"); return; }

    v.srcObject = stream;
    v.setAttribute('playsinline',''); v.setAttribute('muted',''); v.setAttribute('autoplay','');
    try{ await v.play(); }catch(e){ setError(`❌ 再生失敗: ${e.message||e}`); return; }

    $("#btnStart").disabled = true; $("#btnStop").disabled = false;

    // BarcodeDetector
    detector = null;
    if('BarcodeDetector' in window && !FORCE_LEGACY){
      try{ detector = new BarcodeDetector({ formats:['qr_code'] }); }catch{ detector=null; }
    }

    await bindCameraControls();

    stopLoop=false;
    v.requestVideoFrameCallback(processFrame);
    setStatus("棚を先にスキャンしてください（loc-...）");
  }

  function stopCam(){
    stopLoop = true;
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    $("#btnStart").disabled=false; $("#btnStop").disabled=true;
    setStatus("停止中");
  }

  async function bindCameraControls(){
    videoTrack = stream.getVideoTracks()[0];
    imageCapture = ('ImageCapture' in window) ? new ImageCapture(videoTrack) : null;
    const caps = videoTrack.getCapabilities?.() || {};
    camCaps = caps;

    // Torch
    const torchBtn = $("#btnTorch");
    if(caps.torch){
      torchBtn.style.display='inline-block';
      torchBtn.textContent = 'ライト OFF';
      torchBtn.onclick = async ()=>{
        const on = !(videoTrack.getConstraints().advanced?.[0]?.torch);
        await videoTrack.applyConstraints({ advanced:[{ torch:on }] });
        torchBtn.textContent = on ? 'ライト ON' : 'ライト OFF';
      };
    }else{
      torchBtn.style.display='none';
    }

    // Zoom
    const zoomSl = $("#zoom");
    if(typeof caps.zoom === 'number' || (caps.zoom && caps.zoom.min!=null)){
      const min = caps.zoom.min ?? 1, max = caps.zoom.max ?? 5, step = caps.zoom.step ?? 0.1;
      zoomSl.min=min; zoomSl.max=max; zoomSl.step=step; zoomSl.value = videoTrack.getSettings().zoom ?? min;
      zoomSl.style.display='inline-block';
      zoomSl.oninput = ()=> videoTrack.applyConstraints({ advanced:[{ zoom:Number(zoomSl.value) }] });
    }else{
      zoomSl.style.display='none';
    }
  }

  // ========= フレーム処理（間引き + マルチスケール） =========
  let frameSkip=0, SCAN_EVERY=2;

  async function processFrame(ts, meta){
    if(!stream) return;
    if(v.videoWidth){
      c.width = v.videoWidth; c.height = v.videoHeight;
      ctx.filter = 'contrast(120%) brightness(110%)';
      ctx.drawImage(v, 0,0, c.width, c.height);

      if((frameSkip++ % SCAN_EVERY) === 0){
        try{
          const detections = await detectMultiScale(c);
          if(detections && detections.length){
            handleDetections(detections); // 登録/描画
          }
        }catch(e){
          // 失敗は握りつぶして次フレーム
        }
      }
    }
    if(!stopLoop) v.requestVideoFrameCallback(processFrame);
  }

  async function detectMultiScale(canvas){
    const W = canvas.width, H = canvas.height;
    const off = new OffscreenCanvas(W,H);
    const octx = off.getContext('2d', { willReadFrequently:true });
    octx.filter = 'contrast(120%) brightness(110%)';
    octx.drawImage(canvas,0,0,W,H);

    let candidates = [];

    // Pass1: BarcodeDetector
    if(detector){
      try{
        const hits = await detector.detect(off);
        for(const h of hits){
          const pts = h.cornerPoints;
          if(pts && pts.length>=4) candidates.push({ raw:h.rawValue.trim(), box:pts });
        }
      }catch{ /* ignore */ }
    }

    // Pass2: jsQR（縮小）一発ヒットを狙う
    if(candidates.length===0){
      const scales=[0.75,0.6,0.5];
      for(const s of scales){
        const sw=Math.max(320, Math.floor(W*s)), sh=Math.max(240, Math.floor(H*s));
        const small = new OffscreenCanvas(sw,sh);
        const sctx = small.getContext('2d', { willReadFrequently:true });
        sctx.imageSmoothingEnabled=false;
        sctx.drawImage(off, 0,0,sw,sh);
        const img=sctx.getImageData(0,0,sw,sh);
        const hit = jsQR(img.data, sw, sh, { inversionAttempts:'attemptBoth' });
        if(hit){
          const scaleUp=(p)=>({x:p.x*(W/sw), y:p.y*(H/sh)});
          candidates.push({
            raw: hit.data.trim(),
            box: [
              scaleUp(hit.location.topLeftCorner),
              scaleUp(hit.location.topRightCorner),
              scaleUp(hit.location.bottomRightCorner),
              scaleUp(hit.location.bottomLeftCorner),
            ]
          });
          break; // 1つ見つかれば十分
        }
      }
    }

    if(candidates.length===0) return [];

    // Pass3: 候補周辺を原寸で再検証
    const confirmed=[];
    for(const cnd of candidates){
      const xs=cnd.box.map(p=>p.x), ys=cnd.box.map(p=>p.y);
      const pad=24;
      const x0=Math.max(0, Math.min(...xs)-pad)|0, x1=Math.min(W, Math.max(...xs)+pad)|0;
      const y0=Math.max(0, Math.min(...ys)-pad)|0, y1=Math.min(H, Math.max(...ys)+pad)|0;
      const cw=x1-x0, ch=y1-y0; if(cw<30 || ch<30) continue;

      const crop=new OffscreenCanvas(cw,ch);
      const crx=crop.getContext('2d', { willReadFrequently:true });
      crx.drawImage(off, x0,y0,cw,ch, 0,0,cw,ch);
      const img=crx.getImageData(0,0,cw,ch);
      const hit = jsQR(img.data, cw, ch, { inversionAttempts:'attemptBoth' });
      const raw2 = (hit?.data||"").trim();
      if(raw2){
        const loc=hit.location;
        const mapP=(p)=>({x:p.x+x0, y:p.y+y0});
        confirmed.push({
          raw: raw2,
          box: [mapP(loc.topLeftCorner),mapP(loc.topRightCorner),mapP(loc.bottomRightCorner),mapP(loc.bottomLeftCorner)]
        });
      }else{
        confirmed.push({...cnd, weak:true});
      }
    }
    return confirmed;
  }

  // ========= 検出結果の適用 & 描画 =========
  function handleDetections(list){
    const now = performance.now();
    const cool = 300; // 300ms以内の同一rawは無視してチラつき抑制
    const toDraw = [];

    for(const d of list){
      const raw = (d.raw||"").trim();
      if(!raw) continue;
      const last = recentSeen.get(raw) || 0;
      if(now - last < cool) { toDraw.push(d); continue; }
      recentSeen.set(raw, now);

      const kind = classify(raw);
      const p = parse(raw);

      if(kind==="loc" && p.loc){
        if(!fixedLoc || fixedLoc.loc !== p.loc){
          fixedLoc = { loc:p.loc, raw };
          renderLoc();
          setStatus(`棚を固定: ${p.loc}`);
          // 固定時にわかりやすいトースト
          showToastNearBox('棚を固定', d.box, '#075a07');
        }
      }else if(kind==="die" && p.bn && p.wc){
        const key = dieKey(p.bn,p.wc);
        if(!fixedLoc){
          setStatus("先に棚QR（loc-...）を読み取ってください");
        }else if(!fixedDies.has(key)){
          fixedDies.set(key, { bn:p.bn, wc:p.wc, raw, addedAt:Date.now() });
          renderDies();
          setStatus(`型を追加: ${p.bn}-${p.wc}`);
          showToastNearBox('型を登録', d.box, '#333');
        }
      }
      toDraw.push(d);
    }

    drawBoxes(toDraw);
  }

  function drawBoxes(list){
    ctx.save();
    for(const d of list){
      const pts=d.box; if(!pts||pts.length<4) continue;
      ctx.beginPath();
      ctx.moveTo(pts[0].x,pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
      ctx.closePath();

      const isDie = /^die-|[\?&]book=/.test(d.raw);
      const already = isDie && isAlreadyRegistered(d.raw);
      ctx.lineWidth = d.weak ? 2 : 4;
      ctx.strokeStyle = already ? 'rgba(0,180,255,0.95)' : (isDie ? 'rgba(230,60,60,0.95)' : 'rgba(60,180,60,0.95)');
      ctx.stroke();

      // ラベル
      ctx.fillStyle='rgba(0,0,0,0.6)';
      ctx.font='14px system-ui';
      const tag = already ? '登録済み' : (isDie ? '型' : '棚');
      ctx.fillText(tag, pts[0].x+4, pts[0].y-6);
    }
    ctx.restore();
  }

  // ========= 画像からテスト =========
  $("#fileTest").addEventListener("change", async (ev)=>{
    const f = ev.target.files?.[0]; if(!f) return;
    const img = new Image();
    img.onload = async ()=>{
      c.width = img.width; c.height = img.height;
      ctx.filter = 'contrast(120%) brightness(110%)';
      ctx.drawImage(img, 0, 0, c.width, c.height);
      const detections = await detectMultiScale(c);
      handleDetections(detections||[]);
      ev.target.value="";
    };
    img.src = URL.createObjectURL(f);
  });

  // ========= ボタン =========
  $("#btnStart").addEventListener("click", startCam);
  $("#btnStop").addEventListener("click", stopCam);
  $("#btnClearLoc").addEventListener("click", ()=>{ fixedLoc=null; renderLoc(); });
  $("#btnClearDies").addEventListener("click", ()=>{ fixedDies.clear(); renderDies(); });

  // スキャン結果確認（ページ内スクロール）
  $("#btnList").addEventListener("click", ()=>{
    document.querySelector(".panel:nth-of-type(2)")?.scrollIntoView({behavior:'smooth', block:'start'});
  });

  // LastSeen は「年月日だけ」にする（時刻なし）
  function todayYMD(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const dd= String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  }

  $("#btnUpdate").addEventListener("click", async ()=>{
    if(!fixedLoc){ alert("棚（LOC）が未選択です。先に loc-... を読み取ってください。"); return; }
    if(!fixedDies.size){ alert("型が1件もありません。die-... または ?book=&wc= を読み取ってください。"); return; }

    // captured_at は日付のみ送る（サーバ側で LastSeen に流用）
    const ymd = todayYMD();
    const items = [...fixedDies.values()].map(d=>({ book:d.bn, wc:d.wc, wn:"", loc:fixedLoc.loc, captured_at:ymd }));

    const msg = items.map(p=>`• ${p.book}-${p.wc} → ${p.loc} (${ymd})`).join("\n");
    if(!confirm(`以下を Google Sheets に反映します。\n\n${msg}\n\n実行しますか？`)) return;
    try{
      const r = await fetch(SHEET_ENDPOINT, {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ items })
      });
      if(!r.ok) throw new Error(await r.text());
      const j = await r.json();
      if(!j.ok) throw new Error(JSON.stringify(j));
      alert("Google Sheets を更新しました。");
    }catch(e){ alert("更新に失敗しました: " + (e.message||e)); }
  });

  // ========= 初期 =========
  (async ()=>{ setStatus("棚を先にスキャンしてください（loc-...）"); renderLoc(); renderDies(); })();
  </script>
</body>
</html>
