<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>棚→型の順でスキャン（自動登録）</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root { --bd:#ddd; --tx:#222; --sub:#666; --green:#0a7a0a; --blue:#2458e8; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 12px; color: var(--tx); }
  h2 { margin: 6px 0 12px; font-size: 20px; }
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
  .left  { flex: 1 1 360px; min-width: 320px; }
  .right { flex: 1 1 360px; min-width: 320px; }

  .cameraBox { position: relative; display:inline-block; }
  video { width: 360px; max-width: 100%; border:1px solid var(--bd); border-radius:10px; background:#000; display:block; }
  canvas#c { display:none; } /* 処理用（非表示） */
  canvas#ov { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }

  .controlsTop { display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 12px; align-items:center; }
  .controlsTop .btn { font-size:16px; padding: 12px 16px; border-radius: 12px; border:1px solid var(--bd); background:#fff; cursor:pointer; }
  .controlsTop .btn.primary { background:#0a0; color:#fff; border-color:#0a0; }
  .controlsTop .btn.alt     { background:#f6f8ff; color:#123; border-color:#cbd5ff; }

  .muted { color: var(--sub); font-size: 12px; }
  .panel { border:1px solid var(--bd); border-radius:12px; padding:10px; }
  .item  { border:1px solid var(--bd); border-radius:10px; padding:10px; margin-bottom:10px; }
  .head  { font-weight:700; margin-bottom:6px; }
  .kv    { font-size: 13px; }
  .sub   { color: var(--sub); font-size:12px; }
  .actions { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; align-items:center; }
  .btn { padding: 10px 14px; border-radius: 10px; border:1px solid var(--bd); background:#fff; cursor:pointer; }
  .btn.del { color:#b00; border-color:#f0c; }
  .chip { display:inline-block; padding:3px 8px; border:1px solid var(--bd); border-radius:999px; font-size:12px; }

  /* 固定棚バッジ（左上） */
  #fixedBadge {
    position: absolute; left: 10px; top: 10px;
    background: rgba(8,120,8,0.95); color:#fff;
    padding: 8px 12px; border-radius: 10px;
    font-size: 18px; font-weight: 700; /* 2倍相当の強調 */
    box-shadow: 0 2px 8px rgba(0,0,0,0.25);
    pointer-events:none;
  }

  /* フローティングトースト */
  #toast {
    position: fixed; left:50%; transform: translateX(-50%);
    bottom: 18px; background: rgba(32,32,32,0.92); color:#fff;
    padding:10px 14px; border-radius:10px; font-size:14px;
    opacity:0; transition: opacity .2s ease;
    z-index: 50;
  }

  /* 上部の説明＆ボタン */
  .topbar { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
  .topbar .title { font-size:18px; font-weight:700; }
  .topbar .group { display:flex; gap:10px; flex-wrap:wrap; }

  /* 右側の登録リスト */
  .titleSec { display:flex; align-items:center; gap:10px; margin: 0 0 8px; }
  .titleSec h3 { margin:0; font-size:16px; }
</style>
</head>
<body>

  <!-- 上部：説明と主要ボタン -->
  <div class="topbar">
    <div class="title">棚→型の順でスキャン（自動登録）</div>
    <div class="group">
      <button id="btnShowList" class="btn alt">スキャン結果確認</button>
      <button id="btnStart" class="btn primary">カメラ開始</button>
      <button id="btnStop" class="btn">停止</button>
    </div>
  </div>

  <div class="row">
    <!-- 左：カメラ -->
    <div class="left panel">
      <div id="status" class="muted" style="margin-bottom:6px">棚QR（loc-...）を先にスキャンしてください。</div>

      <div class="cameraBox" id="camBox">
        <video id="v" playsinline muted></video>
        <canvas id="c"></canvas>
        <canvas id="ov"></canvas>
        <div id="fixedBadge" style="display:none"></div>
      </div>

      <div class="muted" style="margin-top:8px">
        ・棚QR：<b>loc-LOC-…</b>（プレーン）／ 型QR：<b>die-BookName-WorkCord</b> または <b>?book=&wc=</b><br>
        ・棚を固定したら、型を読み込むたびに自動登録されます（登録済み枠は破線）。
      </div>

      <div class="actions" style="margin-top:10px">
        <label class="btn">画像からテスト<input id="fileTest" type="file" accept="image/*" style="display:none"></label>
      </div>
    </div>

    <!-- 右：登録リスト -->
    <div class="right panel" id="listPanel">
      <div class="titleSec">
        <h3>固定した棚</h3>
        <div id="locLabel" class="kv sub">（未選択）</div>
        <button id="btnClearLoc" class="btn">棚を解除</button>
      </div>

      <div class="titleSec" style="margin-top:8px">
        <h3>固定した型（登録済み）</h3>
        <button id="btnClearDies" class="btn">型リストを全消去</button>
      </div>
      <div id="dieList"></div>

      <div class="actions" style="margin-top:10px">
        <button id="btnUpdate" class="btn primary">確定リンクを Google Sheets に更新</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js" crossorigin="anonymous"></script>
  <script>
  // ========= 設定 =========
  const SHEET_ENDPOINT = "/api/gsheet-seen-bulk";
  const params = new URLSearchParams(location.search);
  const FORCE_LEGACY = params.get("legacy")==="1";
  const SCAN_SCALE = 2;

  // ========= 状態 =========
  let fixedLoc = null; // {loc, raw}
  const fixedDies = new Map(); // key=book-wc -> {bn,wc,wn,raw,addedAt}

  // ========= DOM =========
  const $ = (q)=>document.querySelector(q);
  const v = $("#v"), c = $("#c"), ctx = c.getContext("2d", { willReadFrequently: true });
  const ov = $("#ov"), octx = ov.getContext("2d");
  const capBox = $("#camBox");
  const statusEl = $("#status");
  const toastEl = $("#toast");
  const fixedBadge = $("#fixedBadge");

  function setStatus(t){ statusEl.textContent = t; }
  function toast(t){
    toastEl.textContent = t;
    toastEl.style.opacity = 1;
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=>{ toastEl.style.opacity = 0; }, 1400);
  }

  // ========= 解析ユーティリティ =========
  function classify(s){
    if(/^loc-/i.test(s)) return "loc";
    if(/^die-/i.test(s)) return "die";
    try{ const u=new URL(s); if(u.searchParams.get("book")||u.searchParams.get("wc")) return "die"; }catch{}
    return "other";
  }
  function parsePayload(text){
    const m = /^die-([^-\n]+)-(.+)$/.exec(text);
    if(m){ return { bn:m[1].trim(), wc:m[2].trim() }; }
    try{
      const u=new URL(text);
      const book=(u.searchParams.get("book")||"").trim();
      const wc=(u.searchParams.get("wc")||"").trim();
      // #d= base64url JSON に wn がある場合は抽出
      let wn = "";
      const hash = u.hash || "";
      const mm = /[#&]d=([^&]+)/.exec(hash);
      if(mm){
        try{
          const b64 = mm[1].replace(/-/g,'+').replace(/_/g,'/');
          const json = JSON.parse(decodeURIComponent(escape(atob(b64))));
          wn = (json.wn||"").trim();
        }catch{}
      }
      if(book||wc){ return { bn:book, wc:wc, wn }; }
    }catch{}
    const l=/^loc-(.+)$/i.exec(text);
    if(l){ return { loc:l[1].trim() }; }
    return {};
  }
  const dieKey = (bn,wc)=>`${bn}-${wc}`;

  // ========= UIレンダリング =========
  function renderLoc(){
    $("#locLabel").textContent = fixedLoc ? fixedLoc.loc : "（未選択）";
    if(fixedLoc){
      fixedBadge.style.display = "block";
      fixedBadge.textContent = `固定棚: ${fixedLoc.loc}`;
    }else{
      fixedBadge.style.display = "none";
    }
  }
  function escapeHtml(s){ return String(s??"").replace(/[&<>"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }
  function renderDies(){
    const html = [...fixedDies.values()].map(d=>{
      const key = dieKey(d.bn,d.wc);
      const wnTxt = d.wn ? escapeHtml(d.wn) : "(WorkNameなし)";
      return `<div class="item">
        <div class="head">抜型 <span class="sub">${escapeHtml(d.bn)}</span> [<b>${escapeHtml(d.wc)}</b>] / <span class="sub">WorkName: ${wnTxt}</span></div>
        <div class="actions">
          <button class="btn del" data-del="${key}">この型を削除</button>
          <span class="chip">${escapeHtml(d.raw.length>70 ? d.raw.slice(0,70)+'…' : d.raw)}</span>
        </div>
      </div>`;
    }).join("") || `<div class="muted">（まだ型はありません）</div>`;
    $("#dieList").innerHTML = html;
    $("#dieList").querySelectorAll("button[data-del]").forEach(b=>{
      b.onclick = ()=>{ fixedDies.delete(b.dataset.del); renderDies(); };
    });
  }

  // ========= 枠描画・ラベル描画 =========
  function drawPolygon(g, pts){
    g.beginPath(); g.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
    g.closePath();
  }
  function roundedRect(g, x,y,w,h,r){
    g.beginPath();
    g.moveTo(x+r,y);
    g.arcTo(x+w,y,x+w,y+h,r);
    g.arcTo(x+w,y+h,x,y+h,r);
    g.arcTo(x,y+h,x,y,r);
    g.arcTo(x,y,x+w,y,r);
    g.closePath();
  }
  function drawLabelNearCorners(g, corners, line1, line2, theme){
    const xs=corners.map(p=>p.x), ys=corners.map(p=>p.y);
    const cx=(Math.min(...xs)+Math.max(...xs))/2;
    const topY=Math.min(...ys);

    const padX=10, padY=6;
    g.save();
    g.font = '14px system-ui, sans-serif';
    const w1 = g.measureText(line1).width;
    const w2 = line2 ? g.measureText(line2).width : 0;
    const w  = Math.max(w1, w2) + padX*2;
    const h  = (line2? (14+4) : 14) + padY*2;

    let x = cx - w/2;
    let y = topY - h - 8;
    x = Math.max(6, Math.min(x, ov.width - w - 6));
    y = Math.max(6, Math.min(y, ov.height - h - 6));

    const fill = theme==='loc' ? 'rgba(10,140,10,0.92)' : 'rgba(20,80,200,0.92)';
    const stroke='rgba(255,255,255,0.9)';

    g.fillStyle = fill; g.strokeStyle = stroke; g.lineWidth = 2;
    roundedRect(g, x, y, w, h, 10);
    g.fill(); g.stroke();

    g.fillStyle = '#fff'; g.textBaseline='top'; g.textAlign='left';
    g.fillText(line1, x+padX, y+padY);
    if(line2){ g.fillText(line2, x+padX, y+padY+14+4); }
    g.restore();
  }

  // ========= フィードバック（枠フラッシュ/バブル/音/振動） =========
  const flashes=[]; // {kind,corners,t,ttl}
  const bubbles=[]; // {kind,corners,text,t,ttl}
  function addFlash(kind, corners){ flashes.push({ kind, corners, t:performance.now(), ttl:420 }); }
  function addBubble(kind, corners, text){ bubbles.push({ kind, corners, text, t:performance.now(), ttl:1200 }); }
  function playBeep(freq=880, dur=120){
    try{
      const ac = new (window.AudioContext||window.webkitAudioContext)();
      const o = ac.createOscillator(); const g = ac.createGain();
      o.type='sine'; o.frequency.value=freq; o.connect(g); g.connect(ac.destination);
      o.start(); g.gain.setValueAtTime(0.25, ac.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + dur/1000);
      setTimeout(()=>{ o.stop(); ac.close(); }, dur+50);
    }catch{}
  }
  function buzz(ms=30){ if(navigator.vibrate) try{ navigator.vibrate(ms); }catch{} }

  function drawOverlays(candidates){
    octx.clearRect(0,0,ov.width,ov.height);

    // 候補枠
    for(const c of candidates){
      const isLoc = c.kind==='loc';
      const reg   = c.registered;
      if(reg){
        octx.setLineDash([8,6]);
        octx.lineWidth = 4;
        octx.strokeStyle = isLoc ? 'rgba(0,160,0,0.95)' : 'rgba(0,80,240,0.95)';
        octx.fillStyle   = isLoc ? 'rgba(0,200,0,0.12)' : 'rgba(0,120,255,0.12)';
      }else{
        octx.setLineDash([]);
        octx.lineWidth = 2;
        octx.strokeStyle = isLoc ? 'rgba(0,140,0,0.7)' : 'rgba(0,60,220,0.7)';
        octx.fillStyle   = isLoc ? 'rgba(0,180,0,0.18)' : 'rgba(0,90,255,0.18)';
      }
      drawPolygon(octx, c.corners);
      octx.stroke(); octx.fill();

      // ラベル（DIEは2行目にWorkName）
      if(isLoc){
        drawLabelNearCorners(octx, c.corners, `LOC: ${c.parsed.loc}`, '', 'loc');
      }else{
        const title = `${c.parsed.bn}-${c.parsed.wc}`;
        const wn    = (c.parsed.wn||"").trim() || "(WorkNameなし)";
        drawLabelNearCorners(octx, c.corners, title, `WorkName: ${wn}`, 'die');
      }
    }

    // フラッシュ
    for(let i=flashes.length-1;i>=0;i--){
      const f=flashes[i];
      const el = (performance.now()-f.t)/f.ttl;
      if(el>=1){ flashes.splice(i,1); continue; }
      octx.save();
      octx.setLineDash([]);
      octx.lineWidth = 6*(1-el);
      octx.strokeStyle = f.kind==='loc' ? `rgba(0,180,0,${1-el})` : `rgba(40,100,255,${1-el})`;
      drawPolygon(octx, f.corners); octx.stroke();
      octx.restore();
    }

    // バブル
    for(let i=bubbles.length-1;i>=0;i--){
      const b = bubbles[i];
      const el=(performance.now()-b.t)/b.ttl;
      if(el>=1){ bubbles.splice(i,1); continue; }
      const alpha = 1-Math.min(1, Math.max(0, el));
      const xs=b.corners.map(p=>p.x), ys=b.corners.map(p=>p.y);
      const cx=(Math.min(...xs)+Math.max(...xs))/2;
      const cy=(Math.min(...ys)+Math.max(...ys))/2;

      const pad=8;
      octx.save();
      octx.font='14px system-ui, sans-serif';
      const tw = octx.measureText(b.text).width + pad*2;
      const th = 14 + pad*2;
      let x = cx - tw/2, y = cy - 40 - th;
      x = Math.max(6, Math.min(x, ov.width - tw - 6));
      y = Math.max(6, Math.min(y, ov.height - th - 6));
      octx.globalAlpha = alpha;
      octx.fillStyle = 'rgba(32,32,32,0.92)'; octx.strokeStyle='rgba(255,255,255,0.9)'; octx.lineWidth=2;
      roundedRect(octx, x,y,tw,th,10); octx.fill(); octx.stroke();
      octx.fillStyle='#fff'; octx.textBaseline='top'; octx.fillText(b.text, x+pad, y+pad);
      octx.restore();
    }
  }

  // ========= 検出系 =========
  let stream=null, rafId=null, detector=null, useBD=('BarcodeDetector' in window) && !FORCE_LEGACY;

  function stopCam(){
    cancelAnimationFrame(rafId); rafId=null;
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    $("#btnStart").disabled=false; $("#btnStop").disabled=true;
    setStatus("停止中");
  }

  async function startCam(){
    stopCam();
    setStatus("カメラ起動中…");
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode:{ ideal:'environment' }, width:{ideal:1280}, height:{ideal:720} },
        audio:false
      });
    }catch(e){
      setStatus("カメラ起動失敗: 権限/他アプリ使用中をご確認ください。");
      return;
    }
    v.srcObject=stream; await v.play().catch(()=>{});
    $("#btnStart").disabled=true; $("#btnStop").disabled=false;

    // 描画サイズ同期
    const syncSize=()=>{
      const rect = v.getBoundingClientRect();
      ov.width  = v.videoWidth;  ov.height = v.videoHeight;
      c.width   = v.videoWidth;  c.height  = v.videoHeight;
      ov.style.width = rect.width+'px'; ov.style.height = rect.height+'px';
    };
    syncSize(); window.addEventListener('resize', syncSize);

    detector=null; if(useBD){ try{ detector=new BarcodeDetector({ formats:['qr_code'] }); }catch{ useBD=false; detector=null; } }
    setStatus("棚QR（loc-...）を先にスキャンしてください。");
    tick();
  }

  function jsqrMulti(imgData, w, h, max=12){
    const out=[], data = new Uint8ClampedArray(imgData.data);
    const maskRect = loc=>{
      const xs=[loc.topLeftCorner.x,loc.topRightCorner.x,loc.bottomRightCorner.x,loc.bottomLeftCorner.x];
      const ys=[loc.topLeftCorner.y,loc.topRightCorner.y,loc.bottomRightCorner.y,loc.bottomLeftCorner.y];
      const x0=Math.max(0,Math.min(...xs)|0), x1=Math.min(w,Math.max(...xs)|0);
      const y0=Math.max(0,Math.min(...ys)|0), y1=Math.min(h,Math.max(...ys)|0);
      for(let y=y0;y<y1;y++){ for(let x=x0;x<x1;x++){ const i=(y*w+x)*4; data[i]=data[i+1]=data[i+2]=255; data[i+3]=255; } }
    };
    for(let k=0;k<max;k++){
      const hit = jsQR(data, w, h, { inversionAttempts:'attemptBoth' });
      if(!hit) break;
      out.push(hit); maskRect(hit.location);
    }
    return out;
  }

  async function detectOnce(baseCanvas){
    // オフスクリーンで拡大＆コントラスト調整
    const ow = baseCanvas.width * SCAN_SCALE;
    const oh = baseCanvas.height * SCAN_SCALE;
    const off = new OffscreenCanvas(ow, oh);
    const octx2 = off.getContext("2d", { willReadFrequently:true });
    octx2.imageSmoothingEnabled=false;
    octx2.filter="contrast(120%) brightness(105%)";
    octx2.drawImage(baseCanvas,0,0,ow,oh);

    const results=[];

    // BarcodeDetector
    if(useBD && detector){
      try{
        const codes=await detector.detect(off);
        for(const b of codes){
          const corners = (b.cornerPoints||[]).map(p=>({ x:p.x/SCAN_SCALE, y:p.y/SCAN_SCALE }));
          results.push({ raw:b.rawValue.trim(), corners });
        }
      }catch{ useBD=false; detector=null; }
    }
    // jsQR（複数）
    const imgData=octx2.getImageData(0,0,ow,oh);
    const hits = jsqrMulti(imgData, ow, oh, 14);
    // 重複排除
    const seenRaw = new Set(results.map(r=>r.raw));
    for(const h of hits){
      const raw = h.data.trim();
      if(seenRaw.has(raw)) continue;
      const loc = h.location;
      const corners = [loc.topLeftCorner,loc.topRightCorner,loc.bottomRightCorner,loc.bottomLeftCorner]
        .map(p=>({ x:p.x/SCAN_SCALE, y:p.y/SCAN_SCALE }));
      results.push({ raw, corners });
    }
    return results;
  }

  function autoLock(candidates){
    // 棚を優先ロック
    for(const c of candidates){
      if(c.kind==='loc' && c.parsed.loc){
        if(!fixedLoc || fixedLoc.loc !== c.parsed.loc){
          fixedLoc = { loc:c.parsed.loc, raw:c.raw };
          renderLoc();
          addFlash('loc', c.corners);
          addBubble('loc', c.corners, `棚を固定: ${c.parsed.loc}`);
          playBeep(660,120); buzz(30);
          toast(`棚を固定: ${c.parsed.loc}`);
        }
      }
    }
    // 棚が決まっていれば、型を自動登録
    if(fixedLoc){
      for(const c of candidates){
        if(c.kind!=='die' || !c.parsed.bn || !c.parsed.wc) continue;
        const key = dieKey(c.parsed.bn, c.parsed.wc);
        if(!fixedDies.has(key)){
          const wn = (c.parsed.wn||"").trim();
          fixedDies.set(key, { bn:c.parsed.bn, wc:c.parsed.wc, wn, raw:c.raw, addedAt:Date.now() });
          renderDies();
          addFlash('die', c.corners);
          const title = `${c.parsed.bn}-${c.parsed.wc}`;
          addBubble('die', c.corners, `${title} / WorkName: ${wn || '(なし)'}`);
          playBeep(880,120); buzz(30);
          toast(`型を追加: ${title}`);
        }
      }
    }
  }

  async function tick(){
    if(!stream) return;
    if(v.videoWidth){
      // 描画
      ctx.drawImage(v,0,0,c.width,c.height);

      // 検出
      const rs = await detectOnce(c);
      // 候補に整形（既登録かフラグ付）
      const candidates = rs.map(r=>{
        const kind = classify(r.raw);
        const parsed = parsePayload(r.raw);
        let registered = false;
        if(kind==='loc' && fixedLoc && parsed.loc === fixedLoc.loc) registered = true;
        if(kind==='die' && parsed.bn && parsed.wc && fixedDies.has(dieKey(parsed.bn, parsed.wc))) registered = true;
        return { raw:r.raw, kind, parsed, corners:r.corners, registered };
      });

      // 自動ロック
      autoLock(candidates);

      // オーバーレイ描画
      drawOverlays(candidates);
    }
    rafId = requestAnimationFrame(tick);
  }

  // ========= 送信 =========
  async function submitUpdate(){
    if(!fixedLoc){ alert("棚（LOC）が未選択です。先に loc-... を読み取ってください。"); return; }
    if(!fixedDies.size){ alert("型が1件もありません。die-... または ?book=&wc= を読み取ってください。"); return; }
    // LastSeen は日付のみ（YYYY-MM-DD）
    const ymd = new Date().toISOString().slice(0,10);
    const items = [...fixedDies.values()].map(d=>({ book:d.bn, wc:d.wc, wn:d.wn||"", loc:fixedLoc.loc, captured_at: ymd }));
    const msg = items.map(p=>`• ${p.book}-${p.wc} → ${p.loc}`).join("\n");
    if(!confirm(`以下を Google Sheets に反映します。\n\n${msg}\n\n実行しますか？`)) return;
    try{
      const r = await fetch(SHEET_ENDPOINT, {
        method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ items })
      });
      if(!r.ok) throw new Error(await r.text());
      const j = await r.json();
      if(!j.ok) throw new Error(JSON.stringify(j));
      toast("Google Sheets を更新しました");
      alert("Google Sheets を更新しました。");
    }catch(e){ alert("更新に失敗しました: " + (e.message||e)); }
  }

  // ========= 画像からテスト =========
  $("#fileTest").addEventListener("change", async (ev)=>{
    const f = ev.target.files?.[0]; if(!f) return;
    const img = new Image();
    img.onload = async ()=>{
      c.width = img.width; c.height = img.height;
      ov.width = img.width; ov.height = img.height;
      const rect = v.getBoundingClientRect();
      ov.style.width = rect.width+'px'; ov.style.height = rect.height+'px';
      ctx.drawImage(img, 0, 0, c.width, c.height);

      const rs = await detectOnce(c);
      const candidates = rs.map(r=>{
        const kind = classify(r.raw);
        const parsed = parsePayload(r.raw);
        let registered=false;
        if(kind==='loc' && fixedLoc && parsed.loc===fixedLoc.loc) registered=true;
        if(kind==='die' && parsed.bn && parsed.wc && fixedDies.has(dieKey(parsed.bn,parsed.wc))) registered=true;
        return { raw:r.raw, kind, parsed, corners:r.corners, registered };
      });
      autoLock(candidates);
      drawOverlays(candidates);
      ev.target.value="";
    };
    img.src = URL.createObjectURL(f);
  });

  // ========= ボタン =========
  $("#btnStart").addEventListener("click", startCam);
  $("#btnStop").addEventListener("click", stopCam);
  $("#btnShowList").addEventListener("click", ()=>{ $("#listPanel").scrollIntoView({behavior:'smooth', block:'start'}); });
  $("#btnClearLoc").addEventListener("click", ()=>{ fixedLoc=null; renderLoc(); toast("棚を解除しました"); });
  $("#btnClearDies").addEventListener("click", ()=>{ fixedDies.clear(); renderDies(); toast("型リストを全消去しました"); });
  $("#btnUpdate").addEventListener("click", submitUpdate);

  // ========= 初期 =========
  setStatus("棚QR（loc-...）を先にスキャンしてください。");
  $("#btnStop").disabled = true;
  </script>
</body>
</html>
